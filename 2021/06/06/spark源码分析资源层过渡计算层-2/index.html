<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lemcoden.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="书接上文 上次源码分析之后,笔者自己通读了一遍,发现有些地方,有些问题没有说明白,所以就上篇博客遗留的问题做一个回答  序列化器在哪用到了? 上此聊到RPCEnv对象创建的时候,会创建序列化器,2.3.4版本使用Java默认的序列化器,然后在哪里用呢? 这里先给出NettyRpcHandler recive的代码(怎么找到的?请看上篇博客) 1234567  override def recei">
<meta property="og:type" content="article">
<meta property="og:title" content="spark源码分析资源层过渡计算层-2">
<meta property="og:url" content="https://lemcoden.github.io/2021/06/06/spark%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%B5%84%E6%BA%90%E5%B1%82%E8%BF%87%E6%B8%A1%E8%AE%A1%E7%AE%97%E5%B1%82-2/index.html">
<meta property="og:site_name" content="Lemcoden">
<meta property="og:description" content="书接上文 上次源码分析之后,笔者自己通读了一遍,发现有些地方,有些问题没有说明白,所以就上篇博客遗留的问题做一个回答  序列化器在哪用到了? 上此聊到RPCEnv对象创建的时候,会创建序列化器,2.3.4版本使用Java默认的序列化器,然后在哪里用呢? 这里先给出NettyRpcHandler recive的代码(怎么找到的?请看上篇博客) 1234567  override def recei">
<meta property="og:locale">
<meta property="og:image" content="https://lemcoden.github.io/2021/06/06/spark%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%B5%84%E6%BA%90%E5%B1%82%E8%BF%87%E6%B8%A1%E8%AE%A1%E7%AE%97%E5%B1%82-2/spark_source.png">
<meta property="article:published_time" content="2021-06-06T06:59:21.000Z">
<meta property="article:modified_time" content="2023-02-20T15:20:36.129Z">
<meta property="article:author" content="Lemcoden">
<meta property="article:tag" content="分布式">
<meta property="article:tag" content="大数据计算框架">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lemcoden.github.io/2021/06/06/spark%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%B5%84%E6%BA%90%E5%B1%82%E8%BF%87%E6%B8%A1%E8%AE%A1%E7%AE%97%E5%B1%82-2/spark_source.png">


<link rel="canonical" href="https://lemcoden.github.io/2021/06/06/spark%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%B5%84%E6%BA%90%E5%B1%82%E8%BF%87%E6%B8%A1%E8%AE%A1%E7%AE%97%E5%B1%82-2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-Hans","comments":true,"permalink":"https://lemcoden.github.io/2021/06/06/spark%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%B5%84%E6%BA%90%E5%B1%82%E8%BF%87%E6%B8%A1%E8%AE%A1%E7%AE%97%E5%B1%82-2/","path":"2021/06/06/spark源码分析资源层过渡计算层-2/","title":"spark源码分析资源层过渡计算层-2"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>spark源码分析资源层过渡计算层-2 | Lemcoden</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Lemcoden</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">来自于大数据攻城狮的分享</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%A6%E6%8E%A5%E4%B8%8A%E6%96%87"><span class="nav-number">1.</span> <span class="nav-text"> 书接上文</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%E5%9C%A8%E5%93%AA%E7%94%A8%E5%88%B0%E4%BA%86"><span class="nav-number">1.1.</span> <span class="nav-text"> 序列化器在哪用到了?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%BB%86%E8%8A%82%E9%98%90%E6%98%8E"><span class="nav-number">1.2.</span> <span class="nav-text"> 一个细节阐明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%9B%BE%E6%9C%89%E7%9C%9F%E7%9B%B8"><span class="nav-number">1.3.</span> <span class="nav-text"> 有图有真相</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E5%85%A5%E6%AD%A3%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text"> 进入正题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#worker%E5%BC%80%E5%A7%8B"><span class="nav-number">2.1.</span> <span class="nav-text"> worker开始</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#worker%E6%B3%A8%E5%86%8C%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="nav-number">2.2.</span> <span class="nav-text"> worker注册通信流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="nav-number">2.3.</span> <span class="nav-text"> 提交任务流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E6%A8%A1%E5%BC%8F%E4%B8%8D%E5%90%8C%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="nav-number">2.4.</span> <span class="nav-text"> 不同模式,不同运行方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1master%E5%90%AF%E5%8A%A8driver"><span class="nav-number">2.5.</span> <span class="nav-text"> 通信Master启动Driver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E5%A4%96%E5%88%86%E6%9E%90jdk%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">2.6.</span> <span class="nav-text"> 题外分析jdk进程的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8Edriverwrapper%E5%88%B0%E8%AE%A1%E7%AE%97%E5%B1%82%E4%B8%8A%E5%8D%8A%E9%83%A8"><span class="nav-number">2.7.</span> <span class="nav-text"> 从DriverWrapper到计算层(上半部)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AAapplication"><span class="nav-number">2.8.</span> <span class="nav-text"> 注册一个Application</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lemcoden</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://lemcoden.github.io/2021/06/06/spark%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%B5%84%E6%BA%90%E5%B1%82%E8%BF%87%E6%B8%A1%E8%AE%A1%E7%AE%97%E5%B1%82-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lemcoden">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemcoden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="spark源码分析资源层过渡计算层-2 | Lemcoden">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          spark源码分析资源层过渡计算层-2
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-06 14:59:21" itemprop="dateCreated datePublished" datetime="2021-06-06T14:59:21+08:00">2021-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-02-20 23:20:36" itemprop="dateModified" datetime="2023-02-20T23:20:36+08:00">2023-02-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="书接上文"><a class="markdownIt-Anchor" href="#书接上文"></a> 书接上文</h2>
<p>上次源码分析之后,笔者自己通读了一遍,发现有些地方,有些问题没有说明白,所以就上篇博客遗留的问题做一个回答</p>
<h3 id="序列化器在哪用到了"><a class="markdownIt-Anchor" href="#序列化器在哪用到了"></a> 序列化器在哪用到了?</h3>
<p>上此聊到RPCEnv对象创建的时候,会创建序列化器,2.3.4版本使用Java默认的序列化器,然后在哪里用呢?</p>
<p>这里先给出<font color= #FFA500>NettyRpcHandler recive</font>的代码(怎么找到的?请看上篇博客)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>(</span><br><span class="line">      client: <span class="type">TransportClient</span>,</span><br><span class="line">→       message: <span class="type">ByteBuffer</span>,</span><br><span class="line">      callback: <span class="type">RpcResponseCallback</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">→   <span class="keyword">val</span> messageToDispatch = internalReceive(client, message)</span><br><span class="line">    dispatcher.postRemoteMessage(messageToDispatch, callback)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们看到message原本是字节缓存,通过<font color= #FFA500>internalReceive</font>方法组装成<font color= #FFA500>RequestMessage</font>对象</p>
<span id="more"></span>
<p>那再进internalRecceive方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">internalReceive</span></span>(client: <span class="type">TransportClient</span>, message: <span class="type">ByteBuffer</span>): <span class="type">RequestMessage</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> addr = client.getChannel().remoteAddress().asInstanceOf[<span class="type">InetSocketAddress</span>]</span><br><span class="line">    assert(addr != <span class="literal">null</span>)</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">val</span> clientAddr = <span class="type">RpcAddress</span>(addr.getHostString, addr.getPort)</span><br><span class="line">→   <span class="keyword">val</span> requestMessage = <span class="type">RequestMessage</span>(nettyEnv, client, message)</span><br><span class="line">...</span><br><span class="line">      requestMessage</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>再进<font color= #FFA500>RequestMessage</font></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(nettyEnv: <span class="type">NettyRpcEnv</span>, client: <span class="type">TransportClient</span>, bytes: <span class="type">ByteBuffer</span>): <span class="type">RequestMessage</span> = &#123;</span><br><span class="line">   <span class="keyword">val</span> bis = <span class="keyword">new</span> <span class="type">ByteBufferInputStream</span>(bytes)</span><br><span class="line">   <span class="keyword">val</span> in = <span class="keyword">new</span> <span class="type">DataInputStream</span>(bis)</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">val</span> senderAddress = readRpcAddress(in)</span><br><span class="line">     <span class="keyword">val</span> endpointAddress = <span class="type">RpcEndpointAddress</span>(readRpcAddress(in), in.readUTF())</span><br><span class="line">     <span class="keyword">val</span> ref = <span class="keyword">new</span> <span class="type">NettyRpcEndpointRef</span>(nettyEnv.conf, endpointAddress, nettyEnv)</span><br><span class="line">     ref.client = client</span><br><span class="line">     <span class="keyword">new</span> <span class="type">RequestMessage</span>(</span><br><span class="line">       senderAddress,</span><br><span class="line">       ref,</span><br><span class="line">       <span class="comment">// The remaining bytes in `bytes` are the message content.</span></span><br><span class="line">       nettyEnv.deserialize(client, bytes))</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     in.close()</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们会发现字节缓存前面的部分会通过缓冲流把开头的地址读取出来,然后剩下的部分就是消息内容,这个就是数据报文的设计,有兴趣的同学可以细研究一下.</p>
<p>通过<font color= #FFA500>nettyEnv.deserialize</font>反序列化为对象,而反序列化的方法内部</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span>[netty] <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span></span>[<span class="type">T</span>: <span class="type">ClassTag</span>](client: <span class="type">TransportClient</span>, bytes: <span class="type">ByteBuffer</span>): <span class="type">T</span> = &#123;</span><br><span class="line">  <span class="type">NettyRpcEnv</span>.currentClient.withValue(client) &#123;</span><br><span class="line">    deserialize &#123; () =&gt;</span><br><span class="line">      javaSerializerInstance.deserialize[<span class="type">T</span>](bytes)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是通过java序列化器进行反序列化的.</p>
<h3 id="一个细节阐明"><a class="markdownIt-Anchor" href="#一个细节阐明"></a> 一个细节阐明</h3>
<p>上次我们说代码有send,ask,recive,reciveAndReply这样的消息投递规则,但是有一点需要明确,send方法对应recive方法,ask方法reciveAndReply方法,也就是是说,他们方法是一一对应的,并不是胡乱调用的,具体可以看inbox的proccess方法,其中rpcMessage类型和oneWayMessage类型的区别.篇幅有限这里不再多赘述</p>
<h3 id="有图有真相"><a class="markdownIt-Anchor" href="#有图有真相"></a> 有图有真相</h3>
<p>关于上次的源码分析,在此列出一张图表示,便于读者进行源码追踪</p>
<p><img src="spark_source.png" alt="https://cdn.jsdelivr.net/gh/lemcoden/blog_picture/spark/spark_source.png" /></p>
<p>spark源码1</p>
<h2 id="进入正题"><a class="markdownIt-Anchor" href="#进入正题"></a> 进入正题</h2>
<p>上篇,我们以Master为开端,整体把握了整个RPC环境是如何搭建和运行通信的,这次我们在理解了RPC环境的基础之上,看一下Master和Worker之间的角色启动流程,以及我们提交一个任务时,Driver端是如何将我们所指定的任务jar运行起来的</p>
<h3 id="worker开始"><a class="markdownIt-Anchor" href="#worker开始"></a> worker开始</h3>
<p>上次我们从Master源码开始,这次我们从worker的源码开始,上次我们已经给出worker的包名即org.apache.spark.deploy.worker.Worker,老规矩,也是看main方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(argStrings: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">  <span class="type">Thread</span>.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> <span class="type">SparkUncaughtExceptionHandler</span>(</span><br><span class="line">    exitOnUncaughtException = <span class="literal">false</span>))</span><br><span class="line">  <span class="type">Utils</span>.initDaemon(log)</span><br><span class="line">  <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span></span><br><span class="line">  <span class="keyword">val</span> args = <span class="keyword">new</span> <span class="type">WorkerArguments</span>(argStrings, conf)</span><br><span class="line">  <span class="keyword">val</span> rpcEnv = startRpcEnvAndEndpoint(args.host, args.port, args.webUiPort, args.cores,</span><br><span class="line">    args.memory, args.masters, args.workDir, conf = conf)		</span><br><span class="line">  <span class="keyword">val</span> externalShuffleServiceEnabled = conf.getBoolean(<span class="string">&quot;spark.shuffle.service.enabled&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">val</span> sparkWorkerInstances = scala.sys.env.getOrElse(<span class="string">&quot;SPARK_WORKER_INSTANCES&quot;</span>, <span class="string">&quot;1&quot;</span>).toInt</span><br><span class="line">  require(externalShuffleServiceEnabled == <span class="literal">false</span> || sparkWorkerInstances &lt;= <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;Starting multiple workers on one host is failed because we may launch no more than one &quot;</span> +</span><br><span class="line">      <span class="string">&quot;external shuffle service on each host, please set spark.shuffle.service.enabled to &quot;</span> +</span><br><span class="line">      <span class="string">&quot;false or set SPARK_WORKER_INSTANCES to 1 to resolve the conflict.&quot;</span>)</span><br><span class="line">  rpcEnv.awaitTermination()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不能说是一模一样,可以说是完全一致,这里补充一句,最后的rpcEnv的<font color= #FFA500>awaitTermination</font>方法,调用<font color= #FFA500>dispatcher</font>的同名方法,<font color= #FFA500>dispatcher</font>又是调用<font color= #FFA500>threadpool</font>的同名方法,也就是说,RPCEnv环境启动,实质上是线程池的loop线程启动,可以让dispactcher不断轮询抽取发送到的数据</p>
<p>然后同理,我们进入到worker的<font color= #FFA500>startRpcEnvAndEndpoint</font>的方法里</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">startRpcEnvAndEndpoint</span></span>(</span><br><span class="line">     host: <span class="type">String</span>,</span><br><span class="line">     port: <span class="type">Int</span>,</span><br><span class="line">     webUiPort: <span class="type">Int</span>,</span><br><span class="line">     cores: <span class="type">Int</span>,</span><br><span class="line">     memory: <span class="type">Int</span>,</span><br><span class="line">     masterUrls: <span class="type">Array</span>[<span class="type">String</span>],</span><br><span class="line">     workDir: <span class="type">String</span>,</span><br><span class="line">     workerNumber: <span class="type">Option</span>[<span class="type">Int</span>] = <span class="type">None</span>,</span><br><span class="line">     conf: <span class="type">SparkConf</span> = <span class="keyword">new</span> <span class="type">SparkConf</span>): <span class="type">RpcEnv</span> = &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// The LocalSparkCluster runs multiple local sparkWorkerX RPC Environments</span></span><br><span class="line">   <span class="keyword">val</span> systemName = <span class="type">SYSTEM_NAME</span> + workerNumber.map(_.toString).getOrElse(<span class="string">&quot;&quot;</span>)</span><br><span class="line">   <span class="keyword">val</span> securityMgr = <span class="keyword">new</span> <span class="type">SecurityManager</span>(conf)</span><br><span class="line">   <span class="keyword">val</span> rpcEnv = <span class="type">RpcEnv</span>.create(systemName, host, port, conf, securityMgr)</span><br><span class="line">   <span class="keyword">val</span> masterAddresses = masterUrls.map(<span class="type">RpcAddress</span>.fromSparkURL(_))</span><br><span class="line">   rpcEnv.setupEndpoint(<span class="type">ENDPOINT_NAME</span>, <span class="keyword">new</span> <span class="type">Worker</span>(rpcEnv, webUiPort, cores, memory,</span><br><span class="line">     masterAddresses, <span class="type">ENDPOINT_NAME</span>, workDir, conf, securityMgr))</span><br><span class="line">   rpcEnv</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>rpcEnv的创建方法和Endpoint的注册方法这里不在多赘述,安全相关的跳过去,不具体研究,我们看一下<font color= #FFA500>masterUrls.map</font>方法,这个是master地址的映射方法,因为worker和master不一样,worker启动之后,需要拿到master的地址,和master进行主动通信,所以才有这么一个映射方法,而这里如果是动态,灵活的RPC架构这里应该设计为像dubbo一样具有注册发现的功能,但是和上篇博客类似,我们角色就那么几个,如果额外开发注册发现功能显的杀鸡焉用牛刀的意思</p>
<h3 id="worker注册通信流程"><a class="markdownIt-Anchor" href="#worker注册通信流程"></a> worker注册通信流程</h3>
<p>既然Epc通信环境理解的差不多了,那么我们就可以进入到下一个环节,即RPC环境下具体的通信流程,这里是以woker的注册流程为例</p>
<p>上篇博客说到,EndPoint一旦创建就会发送一个信息执行自己的onStart方法,那么我们首先看一下woker的onStart方法中都有些什么</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onStart</span></span>() &#123;</span><br><span class="line">    assert(!registered)</span><br><span class="line">→    createWorkDir()</span><br><span class="line">→    startExternalShuffleService()</span><br><span class="line">    webUi = <span class="keyword">new</span> <span class="type">WorkerWebUI</span>(<span class="keyword">this</span>, workDir, webUiPort)</span><br><span class="line">    webUi.bind()</span><br><span class="line"></span><br><span class="line">    workerWebUiUrl = <span class="string">s&quot;http://<span class="subst">$publicAddress</span>:<span class="subst">$&#123;webUi.boundPort&#125;</span>&quot;</span></span><br><span class="line">→    registerWithMaster()</span><br><span class="line"></span><br><span class="line">    metricsSystem.registerSource(workerSource)</span><br><span class="line">    metricsSystem.start()</span><br><span class="line">    <span class="comment">// Attach the worker metrics servlet handler to the web ui after the metrics system is started.</span></span><br><span class="line">    metricsSystem.getServletHandlers.foreach(webUi.attachHandler)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>创建一个本地文件夹(类似于命名空间,工作空间这样的操作),开启shuffle服务,还有向Master注册自己</p>
<p>这其中的重点不言而喻,必然是注册Master,我们进入到<font color= #FFA500>registerWithMaster</font>方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">registerWithMaster</span></span>() &#123;</span><br><span class="line">    <span class="comment">// onDisconnected may be triggered multiple times, so don&#x27;t attempt registration</span></span><br><span class="line">    <span class="comment">// if there are outstanding registration attempts scheduled.</span></span><br><span class="line">    registrationRetryTimer <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">        registered = <span class="literal">false</span></span><br><span class="line">→        registerMasterFutures = tryRegisterAllMasters()</span><br><span class="line">        connectionAttemptCount = <span class="number">0</span></span><br><span class="line">→        registrationRetryTimer = <span class="type">Some</span>(forwordMessageScheduler.scheduleAtFixedRate(</span><br><span class="line">          <span class="keyword">new</span> <span class="type">Runnable</span> &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = <span class="type">Utils</span>.tryLogNonFatalError &#123;</span><br><span class="line">              <span class="type">Option</span>(self).foreach(_.send(<span class="type">ReregisterWithMaster</span>))</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="type">INITIAL_REGISTRATION_RETRY_INTERVAL_SECONDS</span>,</span><br><span class="line">          <span class="type">INITIAL_REGISTRATION_RETRY_INTERVAL_SECONDS</span>,</span><br><span class="line">          <span class="type">TimeUnit</span>.<span class="type">SECONDS</span>))</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Some</span>(_) =&gt;</span><br><span class="line">        logInfo(<span class="string">&quot;Not spawning another attempt to register with the master, since there is an&quot;</span> +</span><br><span class="line">          <span class="string">&quot; attempt scheduled already.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><font color= #FFA500>tryRegisterAllMasters</font>?为什么是复数?当然是因为兼容HA的多Master的情况,下面是一个定时调度器,INITIAL_REGISTRATION_RETRY_INTERVAL_SECONDS的常量值为10,也就是说,如果没有回应的话,会每隔10秒向master发送信息.</p>
<p>然后再进入到tryRegisterAllMasters方法中</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">tryRegisterAllMasters</span></span>(): <span class="type">Array</span>[<span class="type">JFuture</span>[_]] = &#123;</span><br><span class="line">→     masterRpcAddresses.map &#123; masterAddress =&gt;</span><br><span class="line">→       registerMasterThreadPool.submit(<span class="keyword">new</span> <span class="type">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            logInfo(<span class="string">&quot;Connecting to master &quot;</span> + masterAddress + <span class="string">&quot;...&quot;</span>)</span><br><span class="line">→             <span class="keyword">val</span> masterEndpoint = rpcEnv.setupEndpointRef(masterAddress, <span class="type">Master</span>.<span class="type">ENDPOINT_NAME</span>)</span><br><span class="line">→             sendRegisterMessageToMaster(masterEndpoint)</span><br><span class="line">          &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> ie: <span class="type">InterruptedException</span> =&gt; <span class="comment">// Cancelled</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt; logWarning(<span class="string">s&quot;Failed to connect to master <span class="subst">$masterAddress</span>&quot;</span>, e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>遍历所有master的地址,并通过线程池执行任务,任务内容是根据master的地址创建相应的EndPointRef并通过EndPointRef向Master本体发送信息(如果这里不懂请参照上篇博客)</p>
<p>然后我们再进入到<font color= #FFA500>sendRegisterMessageToMaster</font>方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">sendRegisterMessageToMaster</span></span>(masterEndpoint: <span class="type">RpcEndpointRef</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    masterEndpoint.send(<span class="type">RegisterWorker</span>(</span><br><span class="line">      workerId,</span><br><span class="line">      host,</span><br><span class="line">      port,</span><br><span class="line">      self,</span><br><span class="line">      cores,</span><br><span class="line">      memory,</span><br><span class="line">      workerWebUiUrl,</span><br><span class="line">      masterEndpoint.address))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>发送了一个<font color= #FFA500>RegisterWoker</font>格式的数据,因为之前说过,EndPointRef的send方法对应Endpoint的receive方法,我们直接看Master的receive方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Unit</span>] = &#123;</span><br><span class="line">....</span><br><span class="line">    <span class="keyword">case</span> <span class="type">RegisterWorker</span>(</span><br><span class="line">      id, workerHost, workerPort, workerRef, cores, memory, workerWebUiUrl, masterAddress) =&gt;</span><br><span class="line">      logInfo(<span class="string">&quot;Registering worker %s:%d with %d cores, %s RAM&quot;</span>.format(</span><br><span class="line">        workerHost, workerPort, cores, <span class="type">Utils</span>.megabytesToString(memory)))</span><br><span class="line">→        <span class="keyword">if</span> (state == <span class="type">RecoveryState</span>.<span class="type">STANDBY</span>) &#123;</span><br><span class="line">        workerRef.send(<span class="type">MasterInStandby</span>)</span><br><span class="line">→        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idToWorker.contains(id)) &#123;</span><br><span class="line">        workerRef.send(<span class="type">RegisterWorkerFailed</span>(<span class="string">&quot;Duplicate worker ID&quot;</span>))</span><br><span class="line">→        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> worker = <span class="keyword">new</span> <span class="type">WorkerInfo</span>(id, workerHost, workerPort, cores, memory,</span><br><span class="line">          workerRef, workerWebUiUrl)</span><br><span class="line">        <span class="keyword">if</span> (registerWorker(worker)) &#123;</span><br><span class="line">          persistenceEngine.addWorker(worker)</span><br><span class="line">          workerRef.send(<span class="type">RegisteredWorker</span>(self, masterWebUiUrl, masterAddress))</span><br><span class="line">          schedule()</span><br><span class="line">→          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">val</span> workerAddress = worker.endpoint.address</span><br><span class="line">          logWarning(<span class="string">&quot;Worker registration failed. Attempted to re-register worker at same &quot;</span> +</span><br><span class="line">            <span class="string">&quot;address: &quot;</span> + workerAddress)</span><br><span class="line">          workerRef.send(<span class="type">RegisterWorkerFailed</span>(<span class="string">&quot;Attempted to re-register worker at same address: &quot;</span></span><br><span class="line">            + workerAddress))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">....</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>receive方法是一个偏函数,即会根据输入参数的格式类型,匹配相应的代码块,这里只摘出RegisterWorker的代码块,注册分三种情况</p>
<ol>
<li>本地Master是Standby模式,通过wokerRef发送<font color= #FFA500>MasterInStandby</font>格式消息</li>
<li>worker已经在本地注册过,注册失败,发送<font color= #FFA500>RegisterWorkerFailed</font>格式消息</li>
<li>注册成功,本地持久化引擎添加worker的信息(地址端口核数内存…),并发送<font color= #FFA500>RegisteredWorker</font>格式消息</li>
</ol>
<p>我们再看以下对应worker的receive方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Unit</span>] = synchronized &#123;</span><br><span class="line">....</span><br><span class="line">    <span class="keyword">case</span> msg: <span class="type">RegisterWorkerResponse</span> =&gt;</span><br><span class="line">      handleRegisterResponse(msg)</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisteredWorker</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">      master: <span class="type">RpcEndpointRef</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">      masterWebUiUrl: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">      masterAddress: <span class="type">RpcAddress</span></span>) <span class="keyword">extends</span> <span class="title">DeployMessage</span> <span class="keyword">with</span> <span class="title">RegisterWorkerResponse</span></span></span><br></pre></td></tr></table></figure>
<p>我们发现没有RegisteredWorker格式的分支,进入到RegisteredWorker,发现其继承自RegisterWorkerResponse,所以我们直接看RegisterWorkerResponse的分支信息,进入<font color= #FFA500>handleRegisterResponse</font>方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">handleRegisterResponse</span></span>(msg: <span class="type">RegisterWorkerResponse</span>): <span class="type">Unit</span> = synchronized &#123;</span><br><span class="line">    msg <span class="keyword">match</span> &#123;</span><br><span class="line">→      <span class="keyword">case</span> <span class="type">RegisteredWorker</span>(masterRef, masterWebUiUrl, masterAddress) =&gt;</span><br><span class="line">        registered = <span class="literal">true</span></span><br><span class="line">→       changeMaster(masterRef, masterWebUiUrl, masterAddress)</span><br><span class="line">→       forwordMessageScheduler.scheduleAtFixedRate(<span class="keyword">new</span> <span class="type">Runnable</span> &#123;</span><br><span class="line">          <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = <span class="type">Utils</span>.tryLogNonFatalError &#123;</span><br><span class="line">            self.send(<span class="type">SendHeartbeat</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="type">HEARTBEAT_MILLIS</span>, <span class="type">TimeUnit</span>.<span class="type">MILLISECONDS</span>)</span><br><span class="line">...</span><br><span class="line">        masterRef.send(<span class="type">WorkerLatestState</span>(workerId, execs.toList, drivers.keys.toSeq))</span><br><span class="line">...</span><br><span class="line">      <span class="keyword">case</span> <span class="type">RegisterWorkerFailed</span>(message) =&gt;</span><br><span class="line">        <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">          logError(<span class="string">&quot;Worker registration failed: &quot;</span> + message)</span><br><span class="line">          <span class="type">System</span>.exit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="type">MasterInStandby</span> =&gt;</span><br><span class="line">        <span class="comment">// Ignore. Master not yet ready.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> <span class="type">HEARTBEAT_MILLIS</span> = conf.getLong(<span class="string">&quot;spark.worker.timeout&quot;</span>, <span class="number">60</span>) * <span class="number">1000</span> / <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>失败和Standby的逻辑不再多说,很简单,如果成功了,将会调用changeMaster方法,并且利用调度其定时发送心跳,心跳的默认为15秒</p>
<p>这里有个changeMaster方法,我们再往下看看</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">changeMaster</span></span>(masterRef: <span class="type">RpcEndpointRef</span>, uiUrl: <span class="type">String</span>, masterAddress: <span class="type">RpcAddress</span>) &#123;</span><br><span class="line">    <span class="comment">// activeMasterUrl it&#x27;s a valid Spark url since we receive it from master.</span></span><br><span class="line">    activeMasterUrl = masterRef.address.toSparkURL</span><br><span class="line">    activeMasterWebUiUrl = uiUrl</span><br><span class="line">    masterAddressToConnect = <span class="type">Some</span>(masterAddress)</span><br><span class="line">    master = <span class="type">Some</span>(masterRef)</span><br><span class="line">    connected = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (reverseProxy) &#123;</span><br><span class="line">      logInfo(<span class="string">s&quot;WorkerWebUI is available at <span class="subst">$activeMasterWebUiUrl</span>/proxy/<span class="subst">$workerId</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Cancel any outstanding re-registration attempts because we found a new master</span></span><br><span class="line">→     cancelLastRegistrationRetry()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>有个<font color= #FFA500>cancelLastRegistrationRetry</font>,继续往里走</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">cancelLastRegistrationRetry</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (registerMasterFutures != <span class="literal">null</span>) &#123;</span><br><span class="line">      registerMasterFutures.foreach(_.cancel(<span class="literal">true</span>))</span><br><span class="line">      registerMasterFutures = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">→     registrationRetryTimer.foreach(_.cancel(<span class="literal">true</span>))</span><br><span class="line">    registrationRetryTimer = <span class="type">None</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们之前不是说有个多次重试发送注册信息嘛,注册成功后这里会取消掉所有的定时发送</p>
<p>好了,这就是woker注册的整个通信流程,一旦这个走通spark内大部分的通信流程基本都可以搞的懂</p>
<h3 id="提交任务流程"><a class="markdownIt-Anchor" href="#提交任务流程"></a> 提交任务流程</h3>
<p>前面我们整个的RPC环境再加上Master与Worker角色,这算是对spark资源层最简单的理解,后期还会有更加深入的讲解,但是源码阅读都是循序渐进的,先把外层源码的壳子理解透彻,我们再深入,所以我们先从简单的资源层理解向简单的计算层理解过渡</p>
<p>说到计算,开始肯定离不开任务的提交,因此我们从spark-submit的shell脚本开始,</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$&#123;SPARK_HOME&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">source</span> <span class="string">&quot;<span class="subst">$(dirname <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span>&quot;</span>/find-spark-home</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># disable randomized hash for string in Python 3.3+</span></span><br><span class="line"><span class="built_in">export</span> PYTHONHASHSEED=0</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$&#123;SPARK_HOME&#125;</span>&quot;</span>/bin/spark-class org.apache.spark.deploy.SparkSubmit <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>发现,很简单直接执行的 SparkSubmit类,我们进入SparkSubmit,看一下main函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// Initialize logging if it hasn&#x27;t been done yet. Keep track of whether logging needs to</span></span><br><span class="line">    <span class="comment">// be reset before the application starts.</span></span><br><span class="line">    <span class="keyword">val</span> uninitLog = initializeLogIfNecessary(<span class="literal">true</span>, silent = <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> appArgs = <span class="keyword">new</span> <span class="type">SparkSubmitArguments</span>(args)</span><br><span class="line">    <span class="keyword">if</span> (appArgs.verbose) &#123;</span><br><span class="line">      <span class="comment">// scalastyle:off println</span></span><br><span class="line">      printStream.println(appArgs)</span><br><span class="line">      <span class="comment">// scalastyle:on println</span></span><br><span class="line">    &#125;</span><br><span class="line">    appArgs.action <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">SparkSubmitAction</span>.<span class="type">SUBMIT</span> =&gt; submit(appArgs, uninitLog)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">SparkSubmitAction</span>.<span class="type">KILL</span> =&gt; kill(appArgs)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">SparkSubmitAction</span>.<span class="type">REQUEST_STATUS</span> =&gt; requestStatus(appArgs)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>参数拼接转换就不多说了,重点看三个action,看来spark-submit不止能提交,还可以杀死容器,查看状态,笔者回头试了以下,发现help里面就有相关的功能的示例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Usage: spark-submit [options] &lt;app jar | python file | R file&gt; [app arguments]</span><br><span class="line">Usage: spark-submit --<span class="built_in">kill</span> [submission ID](...]</span><br><span class="line">Usage: spark-submit --status [submission ID](...]</span><br></pre></td></tr></table></figure>
<p>有时候,没有源码提醒一下,还真不知道有这东西</p>
<p>好了,收回来,我们重点看的是任务是如何提交的,所以需要进入submit方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">submit</span></span>(args: <span class="type">SparkSubmitArguments</span>, uninitLog: <span class="type">Boolean</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doRunMain</span></span>(): <span class="type">Unit</span> = &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In standalone cluster mode, there are two submission gateways:</span></span><br><span class="line">    <span class="comment">//   (1) The traditional RPC gateway using o.a.s.deploy.Client as a wrapper</span></span><br><span class="line">    <span class="comment">//   (2) The new REST-based gateway introduced in Spark 1.3</span></span><br><span class="line">    <span class="comment">// The latter is the default behavior as of Spark 1.3, but Spark submit will fail over</span></span><br><span class="line">    <span class="comment">// to use the legacy gateway if the master endpoint turns out to be not a REST server.</span></span><br><span class="line">→     <span class="keyword">if</span> (args.isStandaloneCluster &amp;&amp; args.useRest) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// scalastyle:off println</span></span><br><span class="line">        printStream.println(<span class="string">&quot;Running Spark using the REST application submission protocol.&quot;</span>)</span><br><span class="line">        <span class="comment">// scalastyle:on println</span></span><br><span class="line">        doRunMain()</span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">				......</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// In all other modes, just run the main class as prepared</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">→       doRunMain()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>有一个嵌套函数doRunMain先跳过,先看下面的判断,发现会判断参数中是否有<font color= #FFA500>useRest</font>,rest风格的提交?感觉和livy有些关系,不过可以肯定的是我们提交都是直接使用的shell脚本,所以走的else分支,所以我们再展开<font color= #FFA500>doRunMain</font>方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def doRunMain(): Unit = &#123;</span><br><span class="line">      <span class="keyword">if</span> (args.proxyUser != null) &#123;</span><br><span class="line">        val proxyUser = UserGroupInformation.createProxyUser(args.proxyUser,</span><br><span class="line">          UserGroupInformation.getCurrentUser())</span><br><span class="line">        try &#123;</span><br><span class="line">          proxyUser.doAs(new PrivilegedExceptionAction[Unit]() &#123;</span><br><span class="line">            override def run(): Unit = &#123;</span><br><span class="line">→               runMain(args, uninitLog)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; catch &#123;</span><br><span class="line">				   .....</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        runMain(args, uninitLog)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有个是否代理用户的判断,不过这不重要,再进入<font color= #FFA500>runMain</font>方法,也就是真正执行我们提交的主类的方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">runMain</span></span>(args: <span class="type">SparkSubmitArguments</span>, uninitLog: <span class="type">Boolean</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> (childArgs, childClasspath, sparkConf, childMainClass) = prepareSubmitEnvironment(args)</span><br><span class="line">		.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先看第一行代码,调用提交环境准备的方法,返回Tuple4格式的一些参数,</p>
<h3 id="不同模式不同运行方式"><a class="markdownIt-Anchor" href="#不同模式不同运行方式"></a> 不同模式,不同运行方式</h3>
<p>我们进入到<font color= #FFA500>prepareSubmitEnvironment</font>看一下参数如何生成的</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[deploy] <span class="function"><span class="keyword">def</span> <span class="title">prepareSubmitEnvironment</span></span>(</span><br><span class="line">      args: <span class="type">SparkSubmitArguments</span>,</span><br><span class="line">      conf: <span class="type">Option</span>[<span class="type">HadoopConfiguration</span>] = <span class="type">None</span>)</span><br><span class="line">      : (<span class="type">Seq</span>[<span class="type">String</span>], <span class="type">Seq</span>[<span class="type">String</span>], <span class="type">SparkConf</span>, <span class="type">String</span>) = &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      doPrepareSubmitEnvironment(args, conf)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> e: <span class="type">SparkException</span> =&gt;</span><br><span class="line">        printErrorAndExit(e.getMessage)</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>prepareSubmitEnvironment调用 <font color= #FFA500>doPrepareSubmitEnvironment</font>,所以再进入</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">doPrepareSubmitEnvironment</span></span>(</span><br><span class="line">      args: <span class="type">SparkSubmitArguments</span>,</span><br><span class="line">      conf: <span class="type">Option</span>[<span class="type">HadoopConfiguration</span>] = <span class="type">None</span>)</span><br><span class="line">      : (<span class="type">Seq</span>[<span class="type">String</span>], <span class="type">Seq</span>[<span class="type">String</span>], <span class="type">SparkConf</span>, <span class="type">String</span>) = &#123;</span><br><span class="line">    <span class="comment">// Return values</span></span><br><span class="line">    <span class="keyword">val</span> childArgs = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">String</span>]()</span><br><span class="line">    <span class="keyword">val</span> childClasspath = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">String</span>]()</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">→     <span class="keyword">var</span> childMainClass = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the cluster manager</span></span><br><span class="line">→     <span class="keyword">val</span> clusterManager: <span class="type">Int</span> = args.master <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;yarn&quot;</span> =&gt; <span class="type">YARN</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;yarn-client&quot;</span> | <span class="string">&quot;yarn-cluster&quot;</span> =&gt;</span><br><span class="line">        printWarning(<span class="string">s&quot;Master <span class="subst">$&#123;args.master&#125;</span> is deprecated since 2.0.&quot;</span> +</span><br><span class="line">          <span class="string">&quot; Please use master \&quot;yarn\&quot; with specified deploy mode instead.&quot;</span>)</span><br><span class="line">        <span class="type">YARN</span></span><br><span class="line">      <span class="keyword">case</span> m <span class="keyword">if</span> m.startsWith(<span class="string">&quot;spark&quot;</span>) =&gt; <span class="type">STANDALONE</span></span><br><span class="line">      <span class="keyword">case</span> m <span class="keyword">if</span> m.startsWith(<span class="string">&quot;mesos&quot;</span>) =&gt; <span class="type">MESOS</span></span><br><span class="line">      <span class="keyword">case</span> m <span class="keyword">if</span> m.startsWith(<span class="string">&quot;k8s&quot;</span>) =&gt; <span class="type">KUBERNETES</span></span><br><span class="line">      <span class="keyword">case</span> m <span class="keyword">if</span> m.startsWith(<span class="string">&quot;local&quot;</span>) =&gt; <span class="type">LOCAL</span></span><br><span class="line">      <span class="keyword">case</span> _ =&gt;</span><br><span class="line">        printErrorAndExit(<span class="string">&quot;Master must either be yarn or start with spark, mesos, k8s, or local&quot;</span>)</span><br><span class="line">        <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">		.......</span><br><span class="line">		<span class="keyword">if</span> (args.isStandaloneCluster) &#123;</span><br><span class="line">→ 			childMainClass = <span class="type">STANDALONE_CLUSTER_SUBMIT_CLASS</span></span><br><span class="line">		&#125;</span><br><span class="line">		.......</span><br><span class="line">		<span class="keyword">if</span> (deployMode == <span class="type">CLIENT</span>) &#123;</span><br><span class="line">→       childMainClass = args.mainClass</span><br><span class="line">		&#125;</span><br><span class="line">		........</span><br><span class="line">&#125;</span><br><span class="line">→  <span class="keyword">private</span>[deploy] <span class="keyword">val</span> <span class="type">STANDALONE_CLUSTER_SUBMIT_CLASS</span> = classOf[<span class="type">ClientApp</span>].getName()</span><br></pre></td></tr></table></figure>
<p>首先预告一下,这个方法巨…长,因为有很多集群部署模式的判断,前四行就是四个参数的初始化,我们重点关注mainClass,因为我们现在主要解决的问题就是我们的主类最终运行的是谁?</p>
<p>然后看下面会根据我们提交shell脚本时,master的参数的不同(资源管理组件的不同),赋值不同的集群管理值,我们目前只关注standlone下的Cluster模式和Client模式,其他的资源管理读者有兴趣可以自行研究</p>
<p>然后再往下,如果时standlone的cluster模式,会给我们的<font color= #FFA500>childMainClass</font>赋值<font color= #FFA500>ClientApp</font>的类,如果是client模式就会直接赋值我们提交jar包时- - class中的主类</p>
<p>好了,运行的主类知道了,我们再返回到runMain方法中</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">runMain</span></span>(args: <span class="type">SparkSubmitArguments</span>, uninitLog: <span class="type">Boolean</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> (childArgs, childClasspath, sparkConf, childMainClass) = prepareSubmitEnvironment(args)</span><br><span class="line">		.......</span><br><span class="line">→		<span class="keyword">val</span> app: <span class="type">SparkApplication</span> = <span class="keyword">if</span> (classOf[<span class="type">SparkApplication</span>].isAssignableFrom(mainClass)) &#123;</span><br><span class="line">      mainClass.newInstance().asInstanceOf[<span class="type">SparkApplication</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// SPARK-4170</span></span><br><span class="line">      <span class="keyword">if</span> (classOf[scala.<span class="type">App</span>].isAssignableFrom(mainClass)) &#123;</span><br><span class="line">        printWarning(<span class="string">&quot;Subclasses of scala.App may not work correctly. Use a main() method instead.&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">new</span> <span class="type">JavaMainApplication</span>(mainClass)</span><br><span class="line">		&#125;</span><br><span class="line">...</span><br><span class="line">→		app.start(childArgs.toArray, sparkConf)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>[spark] <span class="class"><span class="keyword">class</span> <span class="title">ClientApp</span> <span class="keyword">extends</span> <span class="title">SparkApplication</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中间长段落跳过,我们直接看最后,有个app.start方法,把应用启动起来,把哪个应用启动起来?再往前,发现有个判断,判断我们要启动的class是不是SparkApplication的子类是返回本体,不是返回JavaMainApplication,查询了一下发现cluster模式下返回的ClientApp类就是SparkApplication子类,所以这段话可以这么理解</p>
<ul>
<li>
<p>cluster模式下 调用ClientApp的start方法</p>
</li>
<li>
<p>client模式下 调用JavaMainApplication的start方法</p>
</li>
</ul>
<p>那我们分别看一下其对应的start方法,先看JavaMainApplication的</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>], conf: <span class="type">SparkConf</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">→    <span class="keyword">val</span> mainMethod = klass.getMethod(<span class="string">&quot;main&quot;</span>, <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">String</span>](<span class="number">0</span>).getClass)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="type">Modifier</span>.isStatic(mainMethod.getModifiers)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">&quot;The main method in the given main class must be static&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sysProps = conf.getAll.toMap</span><br><span class="line">    sysProps.foreach &#123; <span class="keyword">case</span> (k, v) =&gt;</span><br><span class="line">      sys.props(k) = v</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">→    mainMethod.invoke(<span class="literal">null</span>, args)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>直接拿到我们提交的类,通过反射运行了,也就是我们常常说的client模式程序运行在本地</p>
<p>再看一下,cluster模式下</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>], conf: <span class="type">SparkConf</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">→    <span class="keyword">val</span> driverArgs = <span class="keyword">new</span> <span class="type">ClientArguments</span>(args)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!conf.contains(<span class="string">&quot;spark.rpc.askTimeout&quot;</span>)) &#123;</span><br><span class="line">      conf.set(<span class="string">&quot;spark.rpc.askTimeout&quot;</span>, <span class="string">&quot;10s&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Logger</span>.getRootLogger.setLevel(driverArgs.logLevel)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> rpcEnv =</span><br><span class="line">      <span class="type">RpcEnv</span>.create(<span class="string">&quot;driverClient&quot;</span>, <span class="type">Utils</span>.localHostName(), <span class="number">0</span>, conf, <span class="keyword">new</span> <span class="type">SecurityManager</span>(conf))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> masterEndpoints = driverArgs.masters.map(<span class="type">RpcAddress</span>.fromSparkURL).</span><br><span class="line">      map(rpcEnv.setupEndpointRef(_, <span class="type">Master</span>.<span class="type">ENDPOINT_NAME</span>))</span><br><span class="line">→    rpcEnv.setupEndpoint(<span class="string">&quot;client&quot;</span>, <span class="keyword">new</span> <span class="type">ClientEndpoint</span>(rpcEnv, driverArgs, masterEndpoints, conf))</span><br><span class="line"></span><br><span class="line">    rpcEnv.awaitTermination()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>将我们提交的包含主类在内的参数转换为ClientArguments格式,并在本地启动一个RPC环境,然后注册一个ClientEndPoint,并将转换后的参数输入到Endpoint</p>
<h3 id="通信master启动driver"><a class="markdownIt-Anchor" href="#通信master启动driver"></a> 通信Master启动Driver</h3>
<p>我们知道一旦Endpoint注册就一定会执行它的OnStart方法,我们进入<font color= #FFA500>ClientEndpoint</font>的OnStart方法看一下</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onStart</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    driverArgs.cmd <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;launch&quot;</span> =&gt;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> We could add an env variable here and intercept it in `sc.addJar` that would</span></span><br><span class="line">        <span class="comment">//       truncate filesystem paths similar to what YARN does. For now, we just require</span></span><br><span class="line">        <span class="comment">//       people call `addJar` assuming the jar is in the same directory.</span></span><br><span class="line">→        <span class="keyword">val</span> mainClass = <span class="string">&quot;org.apache.spark.deploy.worker.DriverWrapper&quot;</span></span><br><span class="line">				.....</span><br><span class="line">→        <span class="keyword">val</span> command = <span class="keyword">new</span> <span class="type">Command</span>(mainClass,</span><br><span class="line">          <span class="type">Seq</span>(<span class="string">&quot;&#123;&#123;WORKER_URL&#125;&#125;&quot;</span>, <span class="string">&quot;&#123;&#123;USER_JAR&#125;&#125;&quot;</span>, driverArgs.mainClass) ++ driverArgs.driverOptions,</span><br><span class="line">          sys.env, classPathEntries, libraryPathEntries, javaOpts)</span><br><span class="line">				......</span><br><span class="line">→        <span class="keyword">val</span> driverDescription = <span class="keyword">new</span> <span class="type">DriverDescription</span>(</span><br><span class="line">          driverArgs.jarUrl,</span><br><span class="line">          driverArgs.memory,</span><br><span class="line">          driverArgs.cores,</span><br><span class="line">          driverArgs.supervise,</span><br><span class="line">          command)</span><br><span class="line">→        asyncSendToMasterAndForwardReply[<span class="type">SubmitDriverResponse</span>](</span><br><span class="line">          <span class="type">RequestSubmitDriver</span>(driverDescription))</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;kill&quot;</span> =&gt;</span><br><span class="line">        <span class="keyword">val</span> driverId = driverArgs.driverId</span><br><span class="line">        asyncSendToMasterAndForwardReply[<span class="type">KillDriverResponse</span>](<span class="type">RequestKillDriver</span>(driverId))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>首先判断我们是要运行提交还是要杀死进程,肯定运行提交啊,所以进入launch分支,首先赋值mainClass以<font color= #FFA500>“org.apache.spark.deploy.worker.DriverWrapper”</font>(这个需要记一下,后面会用到),然后将<font color= #FFA500>DriverWrapper</font>类和我们的提交的args.mainClass一起封装进command对象中,然后command和一些其他参数封装进driverDescription对象中,最终通过<font color= #FFA500>asyncSendToMasterAndForwardReply</font>发送给Master,不过这里有一个坑,我们看这个方法名好像是调用send方法发送的,但是进入内部</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">asyncSendToMasterAndForwardReply</span></span>[<span class="type">T</span>: <span class="type">ClassTag</span>](message: <span class="type">Any</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">for</span> (masterEndpoint &lt;- masterEndpoints) &#123;</span><br><span class="line">→      masterEndpoint.ask[<span class="type">T</span>](message).onComplete &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Success</span>(v) =&gt; self.send(v)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Failure</span>(e) =&gt;</span><br><span class="line">          logWarning(<span class="string">s&quot;Error sending messages to master <span class="subst">$masterEndpoint</span>&quot;</span>, e)</span><br><span class="line">      &#125;(forwardMessageExecutionContext)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>结果是调用的ask方法,所以我们接下来不是找的receive方法,而是,Master的<font color= #FFA500>receiveAndReply</font>方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receiveAndReply</span></span>(context: <span class="type">RpcCallContext</span>): <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Unit</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">RequestSubmitDriver</span>(description) =&gt;</span><br><span class="line">      <span class="keyword">if</span> (state != <span class="type">RecoveryState</span>.<span class="type">ALIVE</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> msg = <span class="string">s&quot;<span class="subst">$&#123;Utils.BACKUP_STANDALONE_MASTER_PREFIX&#125;</span>: <span class="subst">$state</span>. &quot;</span> +</span><br><span class="line">          <span class="string">&quot;Can only accept driver submissions in ALIVE state.&quot;</span></span><br><span class="line">        context.reply(<span class="type">SubmitDriverResponse</span>(self, <span class="literal">false</span>, <span class="type">None</span>, msg))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logInfo(<span class="string">&quot;Driver submitted &quot;</span> + description.command.mainClass)</span><br><span class="line">        <span class="keyword">val</span> driver = createDriver(description)</span><br><span class="line">        persistenceEngine.addDriver(driver)</span><br><span class="line">        waitingDrivers += driver</span><br><span class="line">        drivers.add(driver)</span><br><span class="line">→        schedule()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> It might be good to instead have the submission client poll the master to determine</span></span><br><span class="line">        <span class="comment">//       the current status of the driver. For now it&#x27;s simply &quot;fire and forget&quot;.</span></span><br><span class="line"></span><br><span class="line">        context.reply(<span class="type">SubmitDriverResponse</span>(self, <span class="literal">true</span>, <span class="type">Some</span>(driver.id),</span><br><span class="line">          <span class="string">s&quot;Driver successfully submitted as <span class="subst">$&#123;driver.id&#125;</span>&quot;</span>))</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就和worker注册差不多,根据创建的描述信息创建个Driver,并且添加到持久化引擎当中,并且把driver添加到<font color= #FFA500>waitingDrivers</font>,不过driver不是一个独立的程序,它是运行在Execuotor当中的,所以我们需要知道它什么时候放到Executor中.被Executor启动</p>
<p>那我们继续看schedule方法有什么</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">schedule</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (state != <span class="type">RecoveryState</span>.<span class="type">ALIVE</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Drivers take strict precedence over executors</span></span><br><span class="line">→    <span class="keyword">val</span> shuffledAliveWorkers = <span class="type">Random</span>.shuffle(workers.toSeq.filter(_.state == <span class="type">WorkerState</span>.<span class="type">ALIVE</span>))</span><br><span class="line">    <span class="keyword">val</span> numWorkersAlive = shuffledAliveWorkers.size</span><br><span class="line">    <span class="keyword">var</span> curPos = <span class="number">0</span></span><br><span class="line">→    <span class="keyword">for</span> (driver &lt;- waitingDrivers.toList) &#123; <span class="comment">// iterate over a copy of waitingDrivers</span></span><br><span class="line">      <span class="comment">// We assign workers to each waiting driver in a round-robin fashion. For each driver, we</span></span><br><span class="line">      <span class="comment">// start from the last worker that was assigned a driver, and continue onwards until we have</span></span><br><span class="line">      <span class="comment">// explored all alive workers.</span></span><br><span class="line">      <span class="keyword">var</span> launched = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">var</span> numWorkersVisited = <span class="number">0</span></span><br><span class="line">      <span class="keyword">while</span> (numWorkersVisited &lt; numWorkersAlive &amp;&amp; !launched) &#123;</span><br><span class="line">        <span class="keyword">val</span> worker = shuffledAliveWorkers(curPos)</span><br><span class="line">        numWorkersVisited += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (worker.memoryFree &gt;= driver.desc.mem &amp;&amp; worker.coresFree &gt;= driver.desc.cores) &#123;</span><br><span class="line">          launchDriver(worker, driver)</span><br><span class="line">          waitingDrivers -= driver</span><br><span class="line">          launched = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        curPos = (curPos + <span class="number">1</span>) % numWorkersAlive</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">→    startExecutorsOnWorkers()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其实<font color= #FFA500>Master.schedule()&lt;</font>方法在注册worker时也执行了,不过上篇并没有重点提到,也就是说schedule会被多处调用,它主要有两个功能</p>
<ol>
<li>随机打乱workers,并且拿出一个worker,在其符合标准的(内存和和CPU核心数大于我们要求的driver的内存和核心数)executor中启动我们刚刚添加到watingDrivers列表的driver</li>
<li>第三个箭头处,启动在Worker当中的Executor</li>
</ol>
<p>我们目前只研究driver的启动所以进入到<font color= #FFA500>lanuchDriver</font>方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">launchDriver</span></span>(worker: <span class="type">WorkerInfo</span>, driver: <span class="type">DriverInfo</span>) &#123;</span><br><span class="line">    logInfo(<span class="string">&quot;Launching driver &quot;</span> + driver.id + <span class="string">&quot; on worker &quot;</span> + worker.id)</span><br><span class="line">    worker.addDriver(driver)</span><br><span class="line">    driver.worker = <span class="type">Some</span>(worker)</span><br><span class="line">→     worker.endpoint.send(<span class="type">LaunchDriver</span>(driver.id, driver.desc))</span><br><span class="line">    driver.state = <span class="type">DriverState</span>.<span class="type">RUNNING</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>打乱worker后随机挑选一个worker,然后发送<font color= #FFA500>LaunchDriver</font>格式的消息,消息内包含driver的id和描述信息,我们再看worker的接收方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="type">LaunchDriver</span>(driverId, driverDesc) =&gt;</span><br><span class="line">      logInfo(<span class="string">s&quot;Asked to launch driver <span class="subst">$driverId</span>&quot;</span>)</span><br><span class="line">      <span class="keyword">val</span> driver = <span class="keyword">new</span> <span class="type">DriverRunner</span>(</span><br><span class="line">        conf,</span><br><span class="line">        driverId,</span><br><span class="line">        workDir,</span><br><span class="line">        sparkHome,</span><br><span class="line">        driverDesc.copy(command = <span class="type">Worker</span>.maybeUpdateSSLSettings(driverDesc.command, conf)),</span><br><span class="line">        self,</span><br><span class="line">        workerUri,</span><br><span class="line">        securityMgr)</span><br><span class="line">→       drivers(driverId) = driver</span><br><span class="line">→       driver.start()</span><br><span class="line"></span><br><span class="line">→       coresUsed += driverDesc.cores</span><br><span class="line">→       memoryUsed += driverDesc.mem</span><br></pre></td></tr></table></figure>
<p>将driver相关信息塞进DriverRunner并运行,然后将driver使用的计算资源在可用资源中划去</p>
<h3 id="题外分析jdk进程的创建"><a class="markdownIt-Anchor" href="#题外分析jdk进程的创建"></a> 题外分析jdk进程的创建</h3>
<blockquote>
<p>以下纯属笔者个人兴趣,与spark源码分析无关,只看spark源码的可以跳过本小节</p>
</blockquote>
<p>笔者有一定的linux知识基础,也知道java是调用<font color= #FFA500>fork,clone,vfork</font>等系统函数启动的进程和线程,而这里Driver作为一个角色,绝对会以进程的方式被创建,所以这里笔者想确认一下,Driver在jdk当中是否确实是调用内核函数实现的</p>
<p>首先声明,本人使用的是linux系统版本的jdk,与windows版本大相径庭.</p>
<p>那我们继续跟踪<font color= #FFA500>DriverRunner</font>的start方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Starts a thread to run and manage the driver. */</span></span><br><span class="line">  <span class="keyword">private</span>[worker] <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>() = &#123;</span><br><span class="line">→    <span class="keyword">new</span> <span class="type">Thread</span>(<span class="string">&quot;DriverRunner for &quot;</span> + driverId) &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>() &#123;</span><br><span class="line">        <span class="keyword">var</span> shutdownHook: <span class="type">AnyRef</span> = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">→          shutdownHook = <span class="type">ShutdownHookManager</span>.addShutdownHook &#123; () =&gt;</span><br><span class="line">            logInfo(<span class="string">s&quot;Worker shutting down, killing driver <span class="subst">$driverId</span>&quot;</span>)</span><br><span class="line">            kill()</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// prepare driver jars and run driver</span></span><br><span class="line">→          <span class="keyword">val</span> exitCode = prepareAndRunDriver()</span><br><span class="line"></span><br><span class="line">          <span class="comment">// set final state depending on if forcibly killed and process exit code</span></span><br><span class="line">          finalState = <span class="keyword">if</span> (exitCode == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Some</span>(<span class="type">DriverState</span>.<span class="type">FINISHED</span>)</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (killed) &#123;</span><br><span class="line">            <span class="type">Some</span>(<span class="type">DriverState</span>.<span class="type">KILLED</span>)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Some</span>(<span class="type">DriverState</span>.<span class="type">FAILED</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">		      ....</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// notify worker of final driver state, possible exception</span></span><br><span class="line">        worker.send(<span class="type">DriverStateChanged</span>(driverId, finalState.get, finalException))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>另起了一个线程进行driver进程的启动操作,</p>
<p>首先注册了一个钩子函数,在worker被杀死的时候同时杀死worker中的driver进程</p>
<p>然后运行prepareAndRunDriver启动driver进程并根据状态码更新driver运行状态.</p>
<p>那再进入<font color= #FFA500>prepareAndRunDriver</font>方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[worker] <span class="function"><span class="keyword">def</span> <span class="title">prepareAndRunDriver</span></span>(): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> driverDir = createWorkingDirectory()</span><br><span class="line">    <span class="keyword">val</span> localJarFilename = downloadUserJar(driverDir)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">substituteVariables</span></span>(argument: <span class="type">String</span>): <span class="type">String</span> = argument <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;&#123;&#123;WORKER_URL&#125;&#125;&quot;</span> =&gt; workerUrl</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;&#123;&#123;USER_JAR&#125;&#125;&quot;</span> =&gt; localJarFilename</span><br><span class="line">      <span class="keyword">case</span> other =&gt; other</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> If we add ability to submit multiple jars they should also be added here</span></span><br><span class="line">→    <span class="keyword">val</span> builder = <span class="type">CommandUtils</span>.buildProcessBuilder(driverDesc.command, securityManager,</span><br><span class="line">      driverDesc.mem, sparkHome.getAbsolutePath, substituteVariables)</span><br><span class="line"></span><br><span class="line">→    runDriver(builder, driverDir, driverDesc.supervise)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>下在jar包,添加参数先略过,我们重点<font color= #FFA500> CommandUtils.buildProcessBuilder</font>方法,这个方法返回的进程构造器<font color= #FFA500>(ProcessBuilder)</font>已经不是spark的类,而是jdk的rt包的类</p>
<p>我们进入末尾的runDriver方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">runDriver</span></span>(builder: <span class="type">ProcessBuilder</span>, baseDir: <span class="type">File</span>, supervise: <span class="type">Boolean</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    builder.directory(baseDir)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span>(process: <span class="type">Process</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="comment">// Redirect stdout and stderr to files</span></span><br><span class="line">      <span class="keyword">val</span> stdout = <span class="keyword">new</span> <span class="type">File</span>(baseDir, <span class="string">&quot;stdout&quot;</span>)</span><br><span class="line">      <span class="type">CommandUtils</span>.redirectStream(process.getInputStream, stdout)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> stderr = <span class="keyword">new</span> <span class="type">File</span>(baseDir, <span class="string">&quot;stderr&quot;</span>)</span><br><span class="line">      <span class="keyword">val</span> formattedCommand = builder.command.asScala.mkString(<span class="string">&quot;\&quot;&quot;</span>, <span class="string">&quot;\&quot; \&quot;&quot;</span>, <span class="string">&quot;\&quot;&quot;</span>)</span><br><span class="line">      <span class="keyword">val</span> header = <span class="string">&quot;Launch Command: %s\n%s\n\n&quot;</span>.format(formattedCommand, <span class="string">&quot;=&quot;</span> * <span class="number">40</span>)</span><br><span class="line">      <span class="type">Files</span>.append(header, stderr, <span class="type">StandardCharsets</span>.<span class="type">UTF_8</span>)</span><br><span class="line">      <span class="type">CommandUtils</span>.redirectStream(process.getErrorStream, stderr)</span><br><span class="line">    &#125;</span><br><span class="line">    runCommandWithRetry(<span class="type">ProcessBuilderLike</span>(builder), initialize, supervise)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>重定向标准输出,错误输出到文件,然后将budiler包装为ProcessBuilderLike类,输入到<font color= #FFA500>runCommandWithRetry</font></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[worker] <span class="function"><span class="keyword">def</span> <span class="title">runCommandWithRetry</span></span>(</span><br><span class="line">→      command: <span class="type">ProcessBuilderLike</span>, initialize: <span class="type">Process</span> =&gt; <span class="type">Unit</span>, supervise: <span class="type">Boolean</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> exitCode = <span class="number">-1</span></span><br><span class="line">    <span class="comment">// Time to wait between submission retries.</span></span><br><span class="line">    <span class="keyword">var</span> waitSeconds = <span class="number">1</span></span><br><span class="line">    <span class="comment">// A run of this many seconds resets the exponential back-off.</span></span><br><span class="line">    <span class="keyword">val</span> successfulRunDuration = <span class="number">5</span></span><br><span class="line">    <span class="keyword">var</span> keepTrying = !killed</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (keepTrying) &#123;</span><br><span class="line">      logInfo(<span class="string">&quot;Launch Command: &quot;</span> + command.command.mkString(<span class="string">&quot;\&quot;&quot;</span>, <span class="string">&quot;\&quot; \&quot;&quot;</span>, <span class="string">&quot;\&quot;&quot;</span>))</span><br><span class="line"></span><br><span class="line">      synchronized &#123;</span><br><span class="line">        <span class="keyword">if</span> (killed) &#123; <span class="keyword">return</span> exitCode &#125;</span><br><span class="line">→        process = <span class="type">Some</span>(command.start())</span><br><span class="line">        initialize(process.get)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> processStart = clock.getTimeMillis()</span><br><span class="line">      exitCode = process.get.waitFor()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// check if attempting another run</span></span><br><span class="line">      keepTrying = supervise &amp;&amp; exitCode != <span class="number">0</span> &amp;&amp; !killed</span><br><span class="line">      <span class="keyword">if</span> (keepTrying) &#123;</span><br><span class="line">        <span class="keyword">if</span> (clock.getTimeMillis() - processStart &gt; successfulRunDuration * <span class="number">1000</span>L) &#123;</span><br><span class="line">          waitSeconds = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        logInfo(<span class="string">s&quot;Command exited with status <span class="subst">$exitCode</span>, re-launching after <span class="subst">$waitSeconds</span> s.&quot;</span>)</span><br><span class="line">        sleeper.sleep(waitSeconds)</span><br><span class="line">        waitSeconds = waitSeconds * <span class="number">2</span> <span class="comment">// exponential back-off</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exitCode</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>代码虽然长,但大部分是log参数的拼接和状态码的转换我们重点看command(ProcessBuilderLike)的start方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[deploy] <span class="class"><span class="keyword">object</span> <span class="title">ProcessBuilderLike</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(processBuilder: <span class="type">ProcessBuilder</span>): <span class="type">ProcessBuilderLike</span> = <span class="keyword">new</span> <span class="type">ProcessBuilderLike</span> &#123;</span><br><span class="line">→    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>(): <span class="type">Process</span> = processBuilder.start()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">command</span></span>: <span class="type">Seq</span>[<span class="type">String</span>] = processBuilder.command().asScala</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用jdk原生的<font color= #FFA500>processBuilder.start()</font>方法,那再进入原生的方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Only for use by ProcessBuilder.start()</span></span><br><span class="line">    static <span class="type">Process</span> start(<span class="type">String</span>[] cmdarray,</span><br><span class="line">                         java.util.<span class="type">Map</span>&lt;<span class="type">String</span>,<span class="type">String</span>&gt; environment,</span><br><span class="line">                         <span class="type">String</span> dir,</span><br><span class="line">                         <span class="type">ProcessBuilder</span>.<span class="type">Redirect</span>[] redirects,</span><br><span class="line">                         boolean redirectErrorStream)</span><br><span class="line">        <span class="keyword">throws</span> <span class="type">IOException</span></span><br><span class="line">    &#123;</span><br><span class="line">				.......</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span>  f0 = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> f1 = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> f2 = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (redirects == <span class="literal">null</span>) &#123;</span><br><span class="line">                std_fds = <span class="keyword">new</span> int[] &#123; <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                std_fds = <span class="keyword">new</span> int[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (redirects[<span class="number">0</span>] == <span class="type">Redirect</span>.<span class="type">PIPE</span>)</span><br><span class="line">                    std_fds[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (redirects[<span class="number">0</span>] == <span class="type">Redirect</span>.<span class="type">INHERIT</span>)</span><br><span class="line">                    std_fds[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    f0 = <span class="keyword">new</span> <span class="type">FileInputStream</span>(redirects[<span class="number">0</span>].file());</span><br><span class="line">                    std_fds[<span class="number">0</span>] = fdAccess.get(f0.getFD());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (redirects[<span class="number">1</span>] == <span class="type">Redirect</span>.<span class="type">PIPE</span>)</span><br><span class="line">                    std_fds[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (redirects[<span class="number">1</span>] == <span class="type">Redirect</span>.<span class="type">INHERIT</span>)</span><br><span class="line">                    std_fds[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    f1 = <span class="keyword">new</span> <span class="type">FileOutputStream</span>(redirects[<span class="number">1</span>].file(),</span><br><span class="line">                                              redirects[<span class="number">1</span>].append());</span><br><span class="line">                    std_fds[<span class="number">1</span>] = fdAccess.get(f1.getFD());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (redirects[<span class="number">2</span>] == <span class="type">Redirect</span>.<span class="type">PIPE</span>)</span><br><span class="line">                    std_fds[<span class="number">2</span>] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (redirects[<span class="number">2</span>] == <span class="type">Redirect</span>.<span class="type">INHERIT</span>)</span><br><span class="line">                    std_fds[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    f2 = <span class="keyword">new</span> <span class="type">FileOutputStream</span>(redirects[<span class="number">2</span>].file(),</span><br><span class="line">                                              redirects[<span class="number">2</span>].append());</span><br><span class="line">                    std_fds[<span class="number">2</span>] = fdAccess.get(f2.getFD());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			  ........</span><br><span class="line">→        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">UNIXProcess</span></span><br><span class="line">            (toCString(cmdarray[<span class="number">0</span>]),</span><br><span class="line">             argBlock, args.length,</span><br><span class="line">             envBlock, envc[<span class="number">0</span>],</span><br><span class="line">             toCString(dir),</span><br><span class="line">                 std_fds,</span><br><span class="line">             redirectErrorStream);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// In theory, close() can throw IOException</span></span><br><span class="line">            <span class="comment">// (although it is rather unlikely to happen here)</span></span><br><span class="line">            <span class="keyword">try</span> &#123; <span class="keyword">if</span> (f0 != <span class="literal">null</span>) f0.close(); &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; <span class="keyword">if</span> (f1 != <span class="literal">null</span>) f1.close(); &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123; <span class="keyword">if</span> (f2 != <span class="literal">null</span>) f2.close(); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>又是以一长串代码,不过return之前的整长串代码可以用一句话描述,设置标准输入,标准输出和错误输出的文件描述符</p>
<p>而我们需要研究的重点在于最后返回的UNIX进程对象,再进入</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UNIXProcess</span>(<span class="keyword">final</span> byte[] prog,</span><br><span class="line">                <span class="keyword">final</span> byte[] argBlock, <span class="keyword">final</span> int argc,</span><br><span class="line">                <span class="keyword">final</span> byte[] envBlock, <span class="keyword">final</span> int envc,</span><br><span class="line">                <span class="keyword">final</span> byte[] dir,</span><br><span class="line">                <span class="keyword">final</span> int[] fds,</span><br><span class="line">                <span class="keyword">final</span> boolean redirectErrorStream)</span><br><span class="line">            <span class="keyword">throws</span> <span class="type">IOException</span> &#123;</span><br><span class="line"></span><br><span class="line">→        pid = forkAndExec(launchMechanism.ordinal() + <span class="number">1</span>,</span><br><span class="line">                          helperpath,</span><br><span class="line">                          prog,</span><br><span class="line">                          argBlock, argc,</span><br><span class="line">                          envBlock, envc,</span><br><span class="line">                          dir,</span><br><span class="line">                          fds,</span><br><span class="line">                          redirectErrorStream);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doPrivileged((<span class="type">PrivilegedExceptionAction</span>&lt;<span class="type">Void</span>&gt;) () -&gt; &#123;</span><br><span class="line">                initStreams(fds);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="type">PrivilegedActionException</span> ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (<span class="type">IOException</span>) ex.getException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>执行了<font color= #FFA500>forkAndExec</font>方法返回进程ID,再进入</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a process. Depending on the &#123;@code mode&#125; flag, this is done by</span></span><br><span class="line"><span class="comment">     * one of the following mechanisms:</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *   1 - fork(2) and exec(2)</span></span><br><span class="line"><span class="comment">     *   2 - posix_spawn(3P)</span></span><br><span class="line"><span class="comment">     *   3 - vfork(2) and exec(2)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  (4 - clone(2) and exec(2) - obsolete and currently disabled in native code)</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     * @param fds an array of three file descriptors.</span></span><br><span class="line"><span class="comment">     *        Indexes 0, 1, and 2 correspond to standard input,</span></span><br><span class="line"><span class="comment">     *        standard output and standard error, respectively.  On</span></span><br><span class="line"><span class="comment">     *        input, a value of -1 means to create a pipe to connect</span></span><br><span class="line"><span class="comment">     *        child and parent processes.  On output, a value which</span></span><br><span class="line"><span class="comment">     *        is not -1 is the parent pipe fd corresponding to the</span></span><br><span class="line"><span class="comment">     *        pipe which has been created.  An element of this array</span></span><br><span class="line"><span class="comment">     *        is -1 on input if and only if it is &lt;em&gt;not&lt;/em&gt; -1 on</span></span><br><span class="line"><span class="comment">     *        output.</span></span><br><span class="line"><span class="comment">     * @return the pid of the subprocess</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">→    <span class="keyword">private</span> native int forkAndExec(int mode, byte[] helperpath,</span><br><span class="line">                                   byte[] prog,</span><br><span class="line">                                   byte[] argBlock, int argc,</span><br><span class="line">                                   byte[] envBlock, int envc,</span><br><span class="line">                                   byte[] dir,</span><br><span class="line">                                   int[] fds,</span><br><span class="line">                                   boolean redirectErrorStream)</span><br><span class="line">        <span class="keyword">throws</span> <span class="type">IOException</span>;</span><br></pre></td></tr></table></figure>
<p>最终!!!到达了宇宙初始,通过forkAndExec的native方法调用linux的内核函数,注释已经写的非常清楚明了了,笔者的愿望达成了</p>
<h3 id="从driverwrapper到计算层上半部"><a class="markdownIt-Anchor" href="#从driverwrapper到计算层上半部"></a> 从DriverWrapper到计算层(上半部)</h3>
<p>之前源码分析到了Driver的进程已经起来了,具体运行的哪个类呢?当然是刚刚说明要着重记一下的<font color= #FFA500>org.apache.spark.deploy.worker.DriverWrapper</font>类了</p>
<p>然后我们进入DriverWrapper类看一下,DriverWrapper在运行main方法时都干了什么</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    args.toList <span class="keyword">match</span> &#123;</span><br><span class="line">......</span><br><span class="line">        <span class="comment">// Delegate to supplied main class</span></span><br><span class="line">        <span class="keyword">val</span> clazz = <span class="type">Utils</span>.classForName(mainClass)</span><br><span class="line">→        <span class="keyword">val</span> mainMethod = clazz.getMethod(<span class="string">&quot;main&quot;</span>, classOf[<span class="type">Array</span>[<span class="type">String</span>]])</span><br><span class="line">→        mainMethod.invoke(<span class="literal">null</span>, extraArgs.toArray[<span class="type">String</span>])</span><br><span class="line">.......</span><br><span class="line">        rpcEnv.shutdown()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> _ =&gt;</span><br><span class="line">        <span class="comment">// scalastyle:off println</span></span><br><span class="line">        <span class="type">System</span>.err.println(<span class="string">&quot;Usage: DriverWrapper &lt;workerUrl&gt; &lt;userJar&gt; &lt;driverMainClass&gt; [options]&quot;</span>)</span><br><span class="line">        <span class="comment">// scalastyle:on println</span></span><br><span class="line">        <span class="type">System</span>.exit(<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>表示长代码看的笔者头大,就直接捡起重点的展示,Driver里面就直接运行了我们提交的jar包的主类</p>
<p>但是有个问题,我们的主类绝对不会只运行在当前的单进程当中,而是应该分布式的去运行,所以接下来从笔者将会从计算层开始分析,从源码去理解算子是如何散布到分布式的集群当中的</p>
<p>首先我们先拿出一个计算层的示例代码来</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">lesson01_rdd_api01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">		<span class="keyword">val</span> conf: <span class="type">SparkConf</span> = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local&quot;</span>).setAppName(<span class="string">&quot;test01&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">    <span class="keyword">val</span> dataRDD: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.parallelize( <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>) )</span><br><span class="line">		<span class="keyword">val</span> res: <span class="type">RDD</span>[<span class="type">Int</span>] = dataRDD.map((_,<span class="number">1</span>)).reduceByKey(_+_).map(_._1)</span><br><span class="line">    res.foreach(println)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现之后所有的RDD的产生都来自于SparkContext,那么我们就首先分析一下SparkContext</p>
<h3 id="注册一个application"><a class="markdownIt-Anchor" href="#注册一个application"></a> 注册一个Application</h3>
<p>当我打开<font color= #FFA500>SparkContext</font>的时候,一大堆的变量扑面而来,好家伙2300多行代码,所以我们只捡主要的说一下</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _env: <span class="type">SparkEnv</span> = _</span><br><span class="line">........</span><br><span class="line"><span class="comment">// Create and start the scheduler</span></span><br><span class="line">    <span class="keyword">val</span> (sched, ts) = <span class="type">SparkContext</span>.createTaskScheduler(<span class="keyword">this</span>, master, deployMode)</span><br><span class="line">    _schedulerBackend = sched</span><br><span class="line">    _taskScheduler = ts</span><br><span class="line">    _dagScheduler = <span class="keyword">new</span> <span class="type">DAGScheduler</span>(<span class="keyword">this</span>)</span><br><span class="line">........</span><br><span class="line">    <span class="comment">// start TaskScheduler after taskScheduler sets DAGScheduler reference in DAGScheduler&#x27;s</span></span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    _taskScheduler.start()</span><br><span class="line">.......</span><br></pre></td></tr></table></figure>
<p>首先要提点一下最最重点也是最最复杂的对象<font color= #FFA500>SparkEnv,sparkEnv</font>里面有<font color= #FFA500>ShuffleManager,MemoryManager,BlockManager</font>等等计算层不可获缺的管理类,不过笔者只是提前说一下,因为其复杂程度远超本篇博客所能解释的量,所以目前还是聊一下其他两个对象(还有一个<font color= #FFA500>DAGScheduler</font>留到下期)</p>
<ol>
<li>taskScheduler</li>
<li>schedulerBackend</li>
</ol>
<p>首先进入<font color= #FFA500>createTaskScheduler</font>方法,看一下这两个对象是如何建立起来的?进方法之前需要先记录一下,这里taskScheduler会调用start方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">createTaskScheduler</span></span>(</span><br><span class="line">      sc: <span class="type">SparkContext</span>,</span><br><span class="line">      master: <span class="type">String</span>,</span><br><span class="line">      deployMode: <span class="type">String</span>): (<span class="type">SchedulerBackend</span>, <span class="type">TaskScheduler</span>) = &#123;</span><br><span class="line">    <span class="keyword">import</span> <span class="type">SparkMasterRegex</span>._</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When running locally, don&#x27;t try to re-execute tasks on failure.</span></span><br><span class="line">    <span class="keyword">val</span> <span class="type">MAX_LOCAL_TASK_FAILURES</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    master <span class="keyword">match</span> &#123;</span><br><span class="line">		.....</span><br><span class="line">					<span class="keyword">case</span> <span class="type">SPARK_REGEX</span>(sparkUrl) =&gt;</span><br><span class="line">			        <span class="keyword">val</span> scheduler = <span class="keyword">new</span> <span class="type">TaskSchedulerImpl</span>(sc)</span><br><span class="line">			        <span class="keyword">val</span> masterUrls = sparkUrl.split(<span class="string">&quot;,&quot;</span>).map(<span class="string">&quot;spark://&quot;</span> + _)</span><br><span class="line">			        <span class="keyword">val</span> backend = <span class="keyword">new</span> <span class="type">StandaloneSchedulerBackend</span>(scheduler, sc, masterUrls)</span><br><span class="line">			        scheduler.initialize(backend)</span><br><span class="line">			        (backend, scheduler)</span><br><span class="line">		.....</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入方法方法之后发现,create方法会根据master的输入格式返回不同的Scheduler对象,我们调用SparkContext.setMaster有各种格式,比如local,local[*](等等,目前我们专注于Spark协议开头的格式,所以这里只显示出来了SPARK_REGEX分支.</p>
<p>它是直接new了一个<font color= #FFA500>TaskSchedulerImpl</font>实现类,也就是说TaskScheduler本身是写成一个接口(或者叫Scala当中的trait),为了方便后期的扩展实现.</p>
<p>然后new了一个<font color= #FFA500>StandloneSchedulerBackend</font>,并且把TaskScheduler塞了进去</p>
<p>backend单词直译为后端,这个应该是TaskSechduler的守护线程,我们开看一下StandloneSchedulerBackend继承关系</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[spark] <span class="class"><span class="keyword">class</span> <span class="title">StandaloneSchedulerBackend</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">    scheduler: <span class="type">TaskSchedulerImpl</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    sc: <span class="type">SparkContext</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    masters: <span class="type">Array</span>[<span class="type">String</span>]</span>)</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="type">CoarseGrainedSchedulerBackend</span>(scheduler, sc.env.rpcEnv)</span><br><span class="line">  <span class="keyword">with</span> <span class="type">StandaloneAppClientListener</span></span><br><span class="line">  <span class="keyword">with</span> <span class="type">Logging</span> &#123;</span><br></pre></td></tr></table></figure>
<p>它继承自一个CoarsedGrained前缀的SchedulerBackend,为什么单独把粗粒度这个单词放在这里呢?因为这个单词很眼熟啊,我们好像在哪里见过…</p>
<p>对,就是在部署Standlone模式的Executor的时候,集群某个节点总有一个带粗粒度前缀的Executor,既然都有CoarsedGrained前缀,那么他们总会有一些不可告人的共通点,这个等一下解释,时机尚未成熟</p>
<p>那往回倒一倒,<font color= #FFA500>createTaskScheduler</font>除了创建了两个Scheduler之外,TaskScheduler还调用initialize方法,进入这个方法看一下</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span>(backend: <span class="type">SchedulerBackend</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.backend = backend</span><br><span class="line">    schedulableBuilder = &#123;</span><br><span class="line">      schedulingMode <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">SchedulingMode</span>.<span class="type">FIFO</span> =&gt;</span><br><span class="line">          <span class="keyword">new</span> <span class="type">FIFOSchedulableBuilder</span>(rootPool)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">SchedulingMode</span>.<span class="type">FAIR</span> =&gt;</span><br><span class="line">          <span class="keyword">new</span> <span class="type">FairSchedulableBuilder</span>(rootPool, conf)</span><br><span class="line">        <span class="keyword">case</span> _ =&gt;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">s&quot;Unsupported <span class="subst">$SCHEDULER_MODE_PROPERTY</span>: &quot;</span> +</span><br><span class="line">          <span class="string">s&quot;<span class="subst">$schedulingMode</span>&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    schedulableBuilder.buildPools()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>第一句话,将<font color= #FFA500>SchedulerBackend</font>对象赋值给backend,之后,我只能说一句</p>
<p>哦~~~~设置调度模式,Spark Standlone的调度模式只有两种,公平调度和FIFO,这个就不多说了</p>
<p>然后我们再往回倒一倒,刚才说,<font color= #FFA500>taskScheduler</font>创建的时候,会调用它的start方法,那我们进入TaskSchedulerImpl的start方法看一下</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>() &#123;</span><br><span class="line">    backend.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isLocal &amp;&amp; conf.getBoolean(<span class="string">&quot;spark.speculation&quot;</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">      logInfo(<span class="string">&quot;Starting speculative execution thread&quot;</span>)</span><br><span class="line">      speculationScheduler.scheduleWithFixedDelay(<span class="keyword">new</span> <span class="type">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = <span class="type">Utils</span>.tryOrStopSparkContext(sc) &#123;</span><br><span class="line">          checkSpeculatableTasks()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="type">SPECULATION_INTERVAL_MS</span>, <span class="type">SPECULATION_INTERVAL_MS</span>, <span class="type">TimeUnit</span>.<span class="type">MILLISECONDS</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>首先调用了backend的start方法,那再进<font color= #FFA500>StandloneSchedulerBackend.start</font>方法当中</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.start()</span><br><span class="line">		....</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>后面的东西很多,先看第一句,它先调用父类的start方法,那么我们进入粗粒度的父类看一下</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> properties = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[(<span class="type">String</span>, <span class="type">String</span>)]</span><br><span class="line">    <span class="keyword">for</span> ((key, value) &lt;- scheduler.sc.conf.getAll) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key.startsWith(<span class="string">&quot;spark.&quot;</span>)) &#123;</span><br><span class="line">        properties += ((key, value))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO (prashant) send conf instead of properties</span></span><br><span class="line">    driverEndpoint = createDriverEndpointRef(properties)&#123;</span><br><span class="line">				rpcEnv.setupEndpoint(<span class="type">ENDPOINT_NAME</span>, createDriverEndpoint(properties)&#123;</span><br><span class="line">					<span class="keyword">new</span> <span class="type">DriverEndpoint</span>(rpcEnv, properties)</span><br><span class="line">				&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>表示不想一层层往里面进了,就把嵌套的方法都展开了,前面的将参数添加到本地就不说了,重点是后面这句,在本地创建了一个DriverEndPoint并注册到RPCEnv环境当中,注意这个DriverEndPoint 是TaskSchduler的内部类,它才是真正的driver角色,也就是说前面的driverWrapper是个容器,通过运行<font color= #FFA500>mainClass → new sparkContext → new TaskScheduler → new BackendScheduler → start TaskScheduler → start BackendScheduler</font>最终注册了一个真正的Driver角色,那之后的onStart 方法分析,这里就不多说了,读者有兴趣可以自己深入了解.</p>
<p>我们继续往下分析,回到StandloneSchedulerBackend的start方法当中</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.start()</span><br><span class="line">		....</span><br><span class="line">		<span class="keyword">val</span> command = <span class="type">Command</span>(<span class="string">&quot;org.apache.spark.executor.CoarseGrainedExecutorBackend&quot;</span>,</span><br><span class="line">      args, sc.executorEnvs, classPathEntries ++ testingClassPath, libraryPathEntries, javaOpts)</span><br><span class="line">		....</span><br><span class="line">		<span class="keyword">val</span> appDesc = <span class="type">ApplicationDescription</span>(sc.appName, maxCores, sc.executorMemory, command,</span><br><span class="line">      webUrl, sc.eventLogDir, sc.eventLogCodec, coresPerExecutor, initialExecutorLimit)</span><br><span class="line">    client = <span class="keyword">new</span> <span class="type">StandaloneAppClient</span>(sc.env.rpcEnv, masters, appDesc, <span class="keyword">this</span>, conf)</span><br><span class="line">    client.start()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>首先,我们看到了粗粒度的<font color= #FFA500>Execuor</font>类,将它封装成Command,然后塞进<font color= #FFA500>ApplicationDescription</font>里</p>
<p>接下来要干什么?..对就是启动一个应用,我们只前看到有DriverDescription会启动一个Driver,那对应的这个就是启动一个Application了,那么我们进入<font color= #FFA500>StandaloneAppClient</font>的start方法中</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Just launch an rpcEndpoint; it will call back into the listener.</span></span><br><span class="line">    endpoint.set(rpcEnv.setupEndpoint(<span class="string">&quot;AppClient&quot;</span>, <span class="keyword">new</span> <span class="type">ClientEndpoint</span>(rpcEnv)))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>注册了一个<font color= #FFA500>ClientEndPoint</font>那再进ClientEndpoint的start方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onStart</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        registerWithMaster(<span class="number">1</span>)</span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt;</span><br><span class="line">          logWarning(<span class="string">&quot;Failed to connect to master&quot;</span>, e)</span><br><span class="line">          markDisconnected()</span><br><span class="line">          stop()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好嘛,又是向Master注册,不过这里是注册一个Application,剩下的笔者就不重复展示了,直接说这个是发送一个<font color= #FFA500>RegisterApplication</font>格式的消息,那么我们从Master的receive方法里面去找</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="type">RegisterApplication</span>(description, driver) =&gt;</span><br><span class="line">      <span class="comment">// TODO Prevent repeated registrations from some driver</span></span><br><span class="line">      <span class="keyword">if</span> (state == <span class="type">RecoveryState</span>.<span class="type">STANDBY</span>) &#123;</span><br><span class="line">        <span class="comment">// ignore, don&#x27;t send response</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logInfo(<span class="string">&quot;Registering app &quot;</span> + description.name)</span><br><span class="line">        <span class="keyword">val</span> app = createApplication(description, driver)</span><br><span class="line">        registerApplication(app)</span><br><span class="line">        logInfo(<span class="string">&quot;Registered app &quot;</span> + description.name + <span class="string">&quot; with ID &quot;</span> + app.id)</span><br><span class="line">        persistenceEngine.addApplication(app)</span><br><span class="line">        driver.send(<span class="type">RegisteredApplication</span>(app.id, self))</span><br><span class="line">        schedule()</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>通过description和driver(EndpointRef)两个对象真正创建一个应用</p>
<p>注册Application到这里基本也就结尾了</p>
<p>不过我们发现这边最后也调用了schedule方法,刚刚调用schedule方法,是为driver寻找要执行的worker,schedule还有一个作用是启动workder中的executor,启动它给谁用呢?</p>
<p>当然是Application了,所以下期博客会从给Apllication申请Executor资源开始讲起.</p>
<p>好的,本期结束,bye,bye!</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag"># 分布式</a>
              <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6/" rel="tag"># 大数据计算框架</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/05/29/hexo%E5%8D%87%E7%BA%A7-travis-ci%E5%A4%B1%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" rel="prev" title="hexo升级,travis ci失效的问题解决">
                  <i class="fa fa-chevron-left"></i> hexo升级,travis ci失效的问题解决
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/06/24/%E4%BB%8Elinux%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0%E8%A7%92%E5%BA%A6-JAVA%E8%A7%92%E5%BA%A6%E8%81%8AIO%E5%8F%91%E5%B1%95%E5%8F%B2-%E5%B9%B6%E5%8F%99%E8%BF%B0netty/" rel="next" title="从linux内核函数角度,JAVA角度聊IO发展史,并叙述netty">
                  从linux内核函数角度,JAVA角度聊IO发展史,并叙述netty <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lemcoden</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
