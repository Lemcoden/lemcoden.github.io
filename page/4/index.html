<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32*32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16*16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css" integrity="sha256-no0c5ccDODBwp+9hSmV5VvPpKwHCpbVzXHexIkupM6U=" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js" integrity="sha256-a5YRB27CcBwBFcT5EF/f3E4vzIqyHrSR878nseNYw64=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;lemcoden.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Pisces&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;}}</script>
<meta property="og:type" content="website">
<meta property="og:title" content="Lemcoden">
<meta property="og:url" content="https://lemcoden.github.io/page/4/index.html">
<meta property="og:site_name" content="Lemcoden">
<meta property="og:locale">
<meta property="article:author" content="Lemcoden">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lemcoden.github.io/page/4/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;zh-Hans&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;page&#x2F;4&#x2F;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Lemcoden</title><script src="/js/config.js"></script>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?5559683623f16c6f10fe5b4f1cb2f062"></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Lemcoden</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">来自于大数据攻城狮的分享</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lemcoden"
      src="http://picture.lemcoden.xyz/avater.jpeg">
  <p class="site-author-name" itemprop="name">Lemcoden</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lemcoden.github.io/2020/08/16/hdfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://picture.lemcoden.xyz/avater.jpeg">
      <meta itemprop="name" content="Lemcoden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemcoden">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/16/hdfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">hdfs文件系统笔记总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-08-16 21:03:36" itemprop="dateCreated datePublished" datetime="2020-08-16T21:03:36+08:00">2020-08-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-08-17 13:31:32" itemprop="dateModified" datetime="2020-08-17T13:31:32+08:00">2020-08-17</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/hadoop%E7%94%9F%E6%80%81/" itemprop="url" rel="index"><span itemprop="name">hadoop生态</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>关于HDFS原理在此写个总结<br>前三点主要围绕分布式文件系统那么多,为什么apache还要开发自己的文件系统<br>后两点主要围绕hdfs的高可用问题</p>
<h3 id="1-HDFS存储模型"><a href="#1-HDFS存储模型" class="headerlink" title="1.HDFS存储模型"></a>1.HDFS存储模型</h3><ul>
<li><p>1.hdfs的存储模型第一个核心为block(块),hdfs的所有存储文件都是按照块来进行划分的,每个文件可以有不同的块,但是文件中除了最后一个块,每个块的大小必须相同,这个为了保证可以和hadoop计算框架,相适应能够有一个统一的计算单位,这个统一的计算单位block不是固定的,需要根据具体的I/O特性进行调整.</p>
</li>
<li><p>2.除了围绕块之外存储模型还有一个核心是存储副本(replication),副本可以冗余数据保证系统的可靠性.并多个副本存储在不同主机当中可以增加计算程序与数据在同一集群的概率,提升计算的性能.</p>
<h3 id="2-HDFS的角色"><a href="#2-HDFS的角色" class="headerlink" title="2.HDFS的角色"></a>2.HDFS的角色</h3><h4 id="HDFS主要角色"><a href="#HDFS主要角色" class="headerlink" title="HDFS主要角色"></a>HDFS主要角色</h4><p>主要角色有两个namenode和datanode,主要功能包括如下:</p>
</li>
<li><p>1.namenode主要维护文件的元数据</p>
</li>
<li><p>2.datanode主要维护负责block的读和写</p>
</li>
<li><p>3.datanode会与namenode维持心跳,并汇报自己持有的block信息和列表</p>
</li>
<li><p>4.clinet向Namenode交互文件元数据.和datanode交互文件blocks数据<br/></p>
</li>
</ul>
<h4 id="次要角色-SecodaryNamenode"><a href="#次要角色-SecodaryNamenode" class="headerlink" title="次要角色:SecodaryNamenode"></a>次要角色:SecodaryNamenode</h4><p>要聊SecondaryNamenode就需要先知道Namenode是如何持久化元数据文件的<br>首先,NameNode维护元数据是在内存中,如果机器突然宕掉,如果不把元数据写在磁盘上,那时没有办法恢复的,元数据会永久丢失<br/><br>  目前持久化有两种方式:</p>
<ul>
<li>1.通过操作日志文件(EditLog)恢复,也就是每当NameNode有一条对元数据的操作,就会增加一条日志,但是这样的方式有两个缺点,第一随着运行时间的增长,NN的log会变得及大,很浪费磁盘空间,第二点也是运行时间长的话,要恢复需要很长时间,比如这台机器运行了十年,宕掉之后可能机器需要五年的时间恢复.</li>
<li>2.通过内存的快照(fsImage)恢复,就是将某个时间点的内存状态溢写到磁盘上,但这种方式没办法实时的保存,磁盘IO是有瓶颈的,我们不可能隔一两分钟就保存内存的镜像<br>而NameNode保存选择了一个折衷的方式来规避两者明显的缺点:<br>每相隔一个时间点,将Editlog里面的操作写入到fsImage当中,合并成为一个新的fsImage,然后将在之前产生旧EditLog,只保留最近fsImage时间点之后产生EditLog删掉,这样让fsImage滚动更新的方法,使得占少量的磁盘的情况下,能让NN恢复到机器宕掉那一刻的状态.<br>但是如果把这个保存合并快照的工作全都的交给Namenode的话,此节点的压力会很大,所以关于fsImage的滚动合并工作便交给另一个工作节点SecondaryNamenode来执行<h3 id="3-角色交互产生的机制"><a href="#3-角色交互产生的机制" class="headerlink" title="3.角色交互产生的机制"></a>3.角色交互产生的机制</h3><h4 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h4>每次NN启动的时候,都会将最近时间点的fsImage加载进来,然后将EditLog操作合并到系统内存当中,最后将新的fsImage写入,并删除EditLog<br>NN会文件的属性作为元数据,但不包括datanode列表,<br>主要是为了防止<br/><br>NN重启后,DN(DataNode)列表中,有启动不起来DN,此时正好有客户端请求,NN返回了不可靠的DN列表<br/><br>这样的情况发生<br>所以NN,在重启后,会接受所有DN心跳信号和状态报告.<br>当确定NameNode检测某个数据块的副本达到最小值,那么他会被认为副本安全的,当有一定百分比的数据被确认是安全后,NameNode将会退出安全模式.<h4 id="副本放置策略"><a href="#副本放置策略" class="headerlink" title="副本放置策略"></a>副本放置策略</h4>第一个副本放置在本机,第二个副本放在不同机架,第三副本放置在同一机架,之后的副本随机.<br>原因:</li>
<li>为了能在程序计算的时候找到最近的block数据</li>
<li>为了能在机架损毁的时候仍然能保留其完整的<h4 id="HDFS写流程"><a href="#HDFS写流程" class="headerlink" title="HDFS写流程"></a>HDFS写流程</h4><img src="http://picture.lemcoden.xyz/hdfs/hdfs_write.png" alt="读流程"></li>
<li>Client与NN创建连接</li>
<li>NN建立元数据</li>
<li>NN验证元数据是否合理</li>
<li>NN触发副本放置策略,返回DN列表</li>
<li>Clinet将数据块分割为64K数据,并使用chunk(512B)和sumchunk进行填充</li>
<li>Clinet向DataNode发送数据块,第一个DN受到packet后本地保存发送到第二个DN</li>
<li>第二个DN发送到第三个DN</li>
<li>当block传输完成,DN分别向各NN汇报,同时Client继续传输下一个block</li>
<li>所以client和block汇报也是并行的</li>
<li>数据分割是为了保证DN可以在第一个数据包发送完成之后,可以立刻发送给第二个DN,保证传输效率以及传输的一致性,并且这样传输,对客户端来说是透明,客户端只要保证给第一个DataNode传输完整数据就可以.<h4 id="HDFS读流程"><a href="#HDFS读流程" class="headerlink" title="HDFS读流程"></a>HDFS读流程</h4><img src="http://picture.lemcoden.xyz/hdfs/hdfs_read.png" alt="写流程"></li>
<li>为了降低整体的带宽消耗和读延迟，HDFS会尽量让读取程序读取离他最近的副本</li>
<li>如果再读取程序的同一个机架上有一个副本，那么就读该副本</li>
<li>如果一个HDFS集群跨越多个数据中心，那么客户端也将首先读本地数据中心的副本</li>
<li>语义：<br>　　 download a file<br>　　 Client和NN交互文件元数据获取fileBlockLocation<br>　　 NN按距离策略排序返回<br>　　 Client尝试下载Block并且校验数据完整性（校验盒校验）</li>
<li>语义：下载一个文件其实是获取文件的所有的Block元数据，那么子集获取block应该成立<br>　　Hdfs支持Client输出文件的offset自定义连接哪些Block的DN，自定义获取数据<br>　　这个是支持计算层的分治，并行计算的核心（牢记）</li>
</ul>
<h3 id="5-HDFS设置高可用"><a href="#5-HDFS设置高可用" class="headerlink" title="5.HDFS设置高可用"></a>5.HDFS设置高可用</h3><h4 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h4><p>为了提升NN的可靠性,如果集群当中只有一个NN,那么在某些情况下Namenode宕机,那么整个集群就不可用了,所以为了提升整个集群的可用性,我们设置两个NN,一主一备,确保主NN宕掉之后,备用NN能启动起来.</p>
<h4 id="开始实现"><a href="#开始实现" class="headerlink" title="开始实现"></a>开始实现</h4><p>要想让两个NN能够无缝切换,我们必须先实现两个进程的内存同步,有两种方法进行两个机器的进程同步:</p>
<ul>
<li>阻塞同步,就是需要同步数据的时候,主NN进入阻塞状态,等待备用NN同步完毕,然后继续运行,但是在现实生产生活中,这种方式显然是行不通的,我们保证了两个NN的强一致性,但是主NameNode的可用性却大大降低了,也就是Namenode同步数据的时候,我们无法使用这个NN.</li>
<li>非阻塞异步,就是主NN需要同步数据时直接发给备用NN,同时NN保持运行接受客户端请求,等待备用NN同步完毕回调通知主NN.但是这样NN的一致性就无法保证</li>
</ul>
<h4 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h4><p>说到这么不得不谈谈CAP定理,即一致性(Consistency),可用性(Avalible),分区容错性(Partition tolerance)三者只可满足其二</p>
<ul>
<li>分区容错性,当分布式系统中遇到任何网络分区故障时,仍然需要能够保证对外提供满足一致性和可用性的服务,除非整个网络发生故障,通俗一点说,我将数据副本设置到多个节点上,其中一个节点故障了,因为其他节点持有数据副本,仍能对外保持可用一致的服务,我称这个分布式系统具有分区容忍性.</li>
<li>可用性,是指系统提供的服务必须一直处于可用的状态,对于每一个从操作请求总是能够在有限的时间内返回结果.</li>
<li>一致性,指的是数据在多个副本之间能够保持一致的特性,在一致性的需求下,当一个系统在数据一致的状态执行更新操作后,应该保证系统为数据仍然处于一致的状态<h4 id="CAP套用分析"><a href="#CAP套用分析" class="headerlink" title="CAP套用分析"></a>CAP套用分析</h4>我们套用CAP定理再回顾一下之前NN的同步的两种方法,</li>
<li>两个方法都满足分区容忍性,</li>
<li>第一个阻塞同步方法,会影响可用性,导致系统没办法在系统规定时间内返回正确的响应结果,</li>
<li>第二个异步非阻塞方法,没有办法保证一致性,异步回调没有办法保证备用的NN能完全将数据保持同步一致.<h4 id="折衷办法-最终一致性"><a href="#折衷办法-最终一致性" class="headerlink" title="折衷办法:最终一致性"></a>折衷办法:最终一致性</h4>既然CAP没办法全部满足,那么我们能不能选择一个折衷的方法呢?<br>当然有,NN就是使用这种方法,即通过Poxas选举算法保持数据的最终一致性<br>首先,添加一个角色较jounralNode,当NN的命名空间有任何修改时,会告知大部分的JounralNodes进程,standby状态的NN会读取JNs中的信息,并监控EditLog的变化,把变化与应用于自己的命名空间.<br/><br>那如何保证数据的一致性呢?<br>JounralNode一般会大于等于3的基数个,首先JounralNode根据少数服从多数的原则,选择出其中的Leader,Leader只有一个,它负责记录自己和其他的JounralNode是否接受到NameNode的变更信息,超过半数的JounralNode接收到NN的变更信息时,才承认作数据同步是可靠的.通知备用的NN读取JounralNode的信息.这样我们即保证了可用性,也保证了数据同步的最终一致性(弱一致性)<h4 id="zookeeper分布式协调系统自动切换"><a href="#zookeeper分布式协调系统自动切换" class="headerlink" title="zookeeper分布式协调系统自动切换"></a>zookeeper分布式协调系统自动切换</h4>上面我们解决的NN之间的数据同步问题,但是现实是active的NN出现故障的时候,我们只能手动其切换NN,所以我们还需要zookeeper的帮助.<h4 id="新增角色ZK-zookeeper-和ZKFC-ZookeeperFailOver"><a href="#新增角色ZK-zookeeper-和ZKFC-ZookeeperFailOver" class="headerlink" title="新增角色ZK(zookeeper)和ZKFC(ZookeeperFailOver)"></a>新增角色ZK(zookeeper)和ZKFC(ZookeeperFailOver)</h4>当我们启动zookeeper进程的时候,会有两个进程监控我们的NN,一个是zookeeper本身的进程,和JounralNode有着相似的选举算法,也是进程数必须超过zookeeper的奇数倍,zkfc要与zk进程保持心跳,而zkfc主要负责监控和切换主备的Namenode<h4 id="自动主备切换流程详述"><a href="#自动主备切换流程详述" class="headerlink" title="自动主备切换流程详述"></a>自动主备切换流程详述</h4><img src="http://picture.lemcoden.xyz/hdfs/HA" alt="主备切换"></li>
<li>启动两个NN进程,此时两个NN都处于备用的状态</li>
<li>启动zk进程和zkfc进程,当zk进程启动之后,zkfc进程争相在最近的zk进程上建立节点(抢锁),第一个成功建立节点的zkfc进程会将它操控的NN设置为Active,另一个就会被定义为standby</li>
<li>假如zkfc挂掉了,zk进程监控不到zkfc的心跳,会将在zkfc建立的节点删掉,而监控standby的zkfc进程看到zk上的节点消失了,会主动建立节点,并先将active的NN节点降级为standby,自己监控的NN节点升级为active</li>
<li>假如active的NN挂掉了,zkfc进程检测到会删除在zk上建立的节点,而监控standby的zkfc会在zk上建立节点,并测试连接另一个NN是否宕掉,最后将自己监控的NN升级为Active</li>
<li>有一种特殊情况是,Active的NN可以运行可以和DataNode连接,但就是连接不上其他人主机的zkfc,当这个NameNode挂掉的时候,其他zkfc会一直处于阻塞状态,不断的尝试连接挂掉的NN,此时需要检查一下网卡硬件的问题</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lemcoden.github.io/2020/08/13/%E7%8E%A9%E8%BD%ACubuntu-%E3%80%87%E5%A3%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://picture.lemcoden.xyz/avater.jpeg">
      <meta itemprop="name" content="Lemcoden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemcoden">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/13/%E7%8E%A9%E8%BD%ACubuntu-%E3%80%87%E5%A3%B9/" class="post-title-link" itemprop="url">玩转ubuntu 〇壹</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-08-13 20:00:37" itemprop="dateCreated datePublished" datetime="2020-08-13T20:00:37+08:00">2020-08-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-08-08 18:19:15" itemprop="dateModified" datetime="2021-08-08T18:19:15+08:00">2021-08-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="终端-文件管理器"><a class="markdownIt-Anchor" href="#终端-文件管理器"></a> 终端 =&gt; 文件管理器</h4>
<p>在终端输入,nautilus(中文直译为鹦鹉螺,是ubuntu默认文件管理器的名字,戏剧性的是笔者玩的一款游戏terraria,里面的某个boss就是nautilus,所以就顺带记住了)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nautilus ./</span><br></pre></td></tr></table></figure>
<h4 id="pc与手机链接gsconnect方式"><a class="markdownIt-Anchor" href="#pc与手机链接gsconnect方式"></a> pc与手机链接(GSConnect方式)</h4>
<p>主要是因为linux版QQ都是bug,linux也没有微信所以只能通过GSConnect链接手机</p>
<p>来相互传送文件.</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/08/13/%E7%8E%A9%E8%BD%ACubuntu-%E3%80%87%E5%A3%B9/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lemcoden.github.io/2020/06/28/blog%E4%BC%98%E5%8C%96-%E5%9B%BE%E5%BA%8A%E9%80%89%E6%8B%A9-%E5%9B%BE%E7%89%87%E5%8A%A0%E6%B0%B4%E5%8D%B0-%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://picture.lemcoden.xyz/avater.jpeg">
      <meta itemprop="name" content="Lemcoden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemcoden">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/28/blog%E4%BC%98%E5%8C%96-%E5%9B%BE%E5%BA%8A%E9%80%89%E6%8B%A9-%E5%9B%BE%E7%89%87%E5%8A%A0%E6%B0%B4%E5%8D%B0-%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/" class="post-title-link" itemprop="url">blog优化:图床选择&图片加水印&一些问题的解决</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-06-28 09:53:16" itemprop="dateCreated datePublished" datetime="2020-06-28T09:53:16+08:00">2020-06-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-11-09 22:43:50" itemprop="dateModified" datetime="2020-11-09T22:43:50+08:00">2020-11-09</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BB%BA%E7%AB%99/" itemprop="url" rel="index"><span itemprop="name">建站</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>前情提要:<br><a target="_blank" rel="noopener" href="https://lemcoden.xyz/2020/05/20/hexo优化-github-coding双搭建，域名CNAME别称指向/">hexo优化:github+coding双搭建，域名CNAME别称指向</a></p>
<h3 id="关于域名备案"><a href="#关于域名备案" class="headerlink" title="关于域名备案"></a>关于域名备案</h3><p>首先向各位读者道歉,之前向大家推荐了Godaddy的域名注册,笔者发现注册完成之后并不是非常好用,官网难以打开,客服反映慢,并且也不提供备案服务</p>
<p>如果大家像笔者之前的那样注册了Godady的域名,请直接去阿里&amp;腾讯云社区,搜索域名转入,进行相关操作,<font color=00ff00>域名转入需要多交一年的域名租赁费用</font></p>
<p>如果申请国内阿里,腾讯云的,可以直接去备案,<font color=00ff00>备案需要有域名提供商的云服务器,并且需要填写身份信息,备案申请,快的话一个星期才能申请下来</font></p>
<h3 id="关于图床"><a href="#关于图床" class="headerlink" title="关于图床"></a>关于图床</h3><h4 id="怎么加入图片"><a href="#怎么加入图片" class="headerlink" title="怎么加入图片?"></a>怎么加入图片?</h4><p>关于怎么在hexo框架中加入图片,百度肯定有很多方法,笔者也尝试过,比如</p>
<ul>
<li>直接加到github的库当中,然后通过链接引用,但是这样速度很慢,多次打开都是图片坏掉的小图标</li>
<li>使用<em>hexo</em>-asset-<em>image</em>,作为非nodejs的程序员,安装之后,引用图片并没有显示,并且中间还报了各种依赖异常,本人不会解决,所以直接跳过</li>
<li>踩坑之后笔者决定选择用云存储做图床,考虑到成本问题选择七牛云,完全免费</li>
</ul>
<h4 id="七牛云"><a href="#七牛云" class="headerlink" title="七牛云"></a>七牛云</h4><p>关于七牛云的注册,登录,以及申请对象存储,这里笔者不再多赘述,看着官方文档说明都可以做到,这里主要聊一聊申请过程中需要注意的问题</p>
<ul>
<li>千万不要使用顶级域名绑定，可以在DNSpod域名解析那里添加一个子域名，比如这个</li>
</ul>
<p><img src="http://picture.lemcoden.xyz/blog_optimize/picture_sub_domain.png" alt="picture_sub_domain"></p>
<ul>
<li>上传图片之前记得添加前缀，多个路径用/隔开</li>
</ul>
<p><img src="http://picture.lemcoden.xyz/blog_optimize/pic_path.png" alt="pic_path"></p>
<ul>
<li>多图上传推荐用上传工具PicGo</li>
</ul>
<h4 id="PicGo的linux安装方法"><a href="#PicGo的linux安装方法" class="headerlink" title="PicGo的linux安装方法"></a>PicGo的linux安装方法</h4><p><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/PicGo">PicGo的github链接</a></p>
<p>windows和mac直接在release里面下载相应的exe和dmg就可以</p>
<p>linux推荐下载appImage后缀的安装包</p>
<p>下载完成后,操作如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp PicGo-2.3.0-beta.3.AppImage /usr/bin/PicGo</span><br><span class="line">chmod +x /usr/bin/PicGo</span><br><span class="line">PicGo</span><br></pre></td></tr></table></figure>

<p>然后直接命令输入PicGo运行就可以了</p>
<p>如果出现如下异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xclip not found</span><br></pre></td></tr></table></figure>

<p>控制台输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install xclip -y</span><br></pre></td></tr></table></figure>

<p>安装xclip即可</p>
<p>这里放一个PicGo的配置参考</p>
<p><img src="http://picture.lemcoden.xyz/blog_optimize/conf_pic_go.png" alt="conf_pic_go"></p>
<p>存储区域华南,华北那些在官方文档有对应的参考映射值</p>
<p><a target="_blank" rel="noopener" href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html#%E4%B8%83%E7%89%9B%E5%9B%BE%E5%BA%8A">官方配置指南</a></p>
<h4 id="关于图片加水印"><a href="#关于图片加水印" class="headerlink" title="关于图片加水印"></a>关于图片加水印</h4><p>为了防止别人盗图,笔者特意写了一个加水印的脚本,逻辑很简单的一个shell脚本,基于image magic库对图片进行编辑,下面放出地址</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Lemcoden/blog.tools">https://github.com/Lemcoden/blog.tools</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lemcoden.github.io/2020/06/25/jvm%E7%9A%84%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%88%BD%E5%8F%A3%E8%AE%B2%E8%A7%A3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BF%97%E7%A7%B0%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89%E3%80%87%E8%82%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://picture.lemcoden.xyz/avater.jpeg">
      <meta itemprop="name" content="Lemcoden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemcoden">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/25/jvm%E7%9A%84%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%88%BD%E5%8F%A3%E8%AE%B2%E8%A7%A3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BF%97%E7%A7%B0%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89%E3%80%87%E8%82%86/" class="post-title-link" itemprop="url"> jvm的轻量级爽口讲解--内存管理子系统（俗称垃圾回收）〇肆</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-06-25 19:06:25" itemprop="dateCreated datePublished" datetime="2020-06-25T19:06:25+08:00">2020-06-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-06-26 22:17:08" itemprop="dateModified" datetime="2020-06-26T22:17:08+08:00">2020-06-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">jvm虚拟机</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h4><p><a target="_blank" rel="noopener" href="https://lemcoden.xyz/2020/06/18/jvm的轻量级爽口讲解-内存管理子系统（俗称垃圾回收）〇叁/">jvm的轻量级爽口讲解–内存管理子系统（俗称垃圾回收）〇贰</a><br/></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表示博客已经优化到博主比较满意的程度，图片加载问题已解决，jvm系列文章的封面也使用了自己设计的封面，首页菜单添加jvm和blog建站的专栏．虽然说的有点像枯燥的开发日志，但是能看到自己的东西越做越好真是由衷的发自内心的高兴，在这里博主祝大家端午节快乐，来口粽子，来口ｊｖｍ小菜（恩，没毛病）</span><br></pre></td></tr></table></figure>
<h4 id="上次没吃完的一口粽子之安全点不够用？"><a href="#上次没吃完的一口粽子之安全点不够用？" class="headerlink" title="上次没吃完的一口粽子之安全点不够用？"></a><font color=#3.5169E1>上次没吃完的一口粽子之安全点不够用？</font></h4><p>上次我们讲了，ｊｖｍ虚拟机一般是在并发标记回收时，通过设置安全点来实现用户线程的停顿，确切的说是主动式中断的安全点（设置一个轮询问标志，一旦发现论询标志为真时，就跑到附近的安全点去挂起．），但是遇到程序暂停执行的情况就不够用了，比如说线程的sleep和blocked状态，这个时候，他是无法响应程序的中断请求的．<br/></p>
<p>因此我们还需要另一种方式，来让线程中断，这就是<font color=#00ff00>安全区域</font>，其实完全就可以理解为被拉成线的安全点，当线程跑到安全区域时，会标识自己已进入，这样回收线程启动，就不会再管安全区域的对象，而在回收线程运行期间，安全区域的线程没有收到回收完毕的信号，是不会离开安全区域的，这就保证了安全区域的安全性（有点套娃）</p>
<h4 id="刚蒸好的新粽子之新老年代如何同时收集？"><a href="#刚蒸好的新粽子之新老年代如何同时收集？" class="headerlink" title="刚蒸好的新粽子之新老年代如何同时收集？"></a><font color=#3.5169E1>刚蒸好的新粽子之新老年代如何同时收集？</font></h4><p>之前我们介绍了＂经典＂（这里是新老年代分代，如果把到目前为止可以稳定使用定义为经典的话，需要再加上Ｇ１回收器）的回收器，都是新老年代分管，并进行组合使用的．<font color=#3.5169E1>但是那之后的新型回收器都是新老年代同时进行收集的，他们是如何做到呢？</font><br>让我们重新再回到理论阶段来解读<br/><br>我们已知的分代理论出自分带收集理论，当时有两个假说做支撑：<br/><br><font color=#00ff00>强分代假说</font>：绝大多数对象都是朝生夕灭的<br/><br><font color=#00ff00>弱分代价说</font>：熬过多次垃圾回收的对象，就越难以消亡．<br/><br>这和我们现在的<font color=#00ff00>垃圾回收流程</font>相对应:<br/></p>
<ol>
<li>开始生成的对象会放到eden区当中，等eden区满，触发一次<font color=#00ff00>minor GC（有时候也叫young GC）</font>，熬过第一次回收的对象会放到survivor区．</li>
<li>等suvivor区满，再进行一次minor GC，并计算幸存对象熬过ＧＣ的次数，将熬过多次（默认１５次，可用参数调节）幸存对象放到old区中．</li>
<li>老年代区域满了收集器触发Full GC，回收整个堆以及方法区内存．</li>
</ol>
<p>讲到这里大家就要问了，<font color=#3.5169E1>老年代区域满了为什么不直接回收老年代区域的内存？</font><br/><br>问的好!<del>话说完全是你自己自问自答啊！！！</del>这是因为可能会出现老年代引用新生代的对象，即出现跨代引用问题．<br>如果出现跨代引用，我们回收老年代的引用同时，势必要查询到引用到年轻代的对象，因此会连带年轻代的对象同时回收<br>，所以老一代的回收器都是old区域满了，进行一次<font color=#00ff00>FullGC</font>.<br/>（在这里多嘴一句，<font color=#00ff00>FullGC</font>很容易和<font  color=#00ff00> MajorGC</font>，<font color=#00ff00>OldGC</font>搞混，原因是CMS回收器之前是没有Old GC这个说法的，Old区满直接Full GC，目前只有CMS收集器能进行所谓的old GC,即只回收老年代的内存，所以CMS收集器出来之后，大家就old区满这个原因，混淆了old GC 和Full GC的说法，而Ｍajor GC更加说不清楚，各个资料各有个的说法）<br>所以就跨代引用问题，在这之后又出现了一个新的假说，叫做<br/></p>
<ul>
<li><font color=#00ff00>跨代引用假说</font>：  存在相互引用关系的两个对象，是应该倾向于同时生存和同时消亡．</li>
</ul>
<p>举个栗子，如果新生代存在跨代引用，那么回收的时候，老年代势必会使新生代对象得以存活，那么我们就不必在为了少量的跨带引用去回收老年代，我们只需要在新生代上建立一个全局的数据结构（叫做记忆集），当我们触发minor GC 的时候，只有包含跨带引用的小块内存里的对象才会被加入到GC Roots进行扫描回收．<br/><br>基于<font color=#00ff00>记忆集</font>我们也可以实现老年代的独立GC(CMS收集器).也可以实现新老年代的同时收集(G1收集器)<br/></p>
<h4 id="最后一口肉粽子之经典收集器的控制参数"><a href="#最后一口肉粽子之经典收集器的控制参数" class="headerlink" title="最后一口肉粽子之经典收集器的控制参数"></a><font color=#3.5169E1 >最后一口肉粽子之经典收集器的控制参数</font></h4><p>好的，新的理论假说已经聊清楚了，我们再回到之前讲的经典收集器．之前所介绍的经典收集器分为串行和并行？<del>不！你没讲过</del>（其实就是单核和多核并行）我们按收集器的顺序，再把收集器的调节参数讲一讲</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>所属收集器</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:SuvivorRatio</td>
<td>新生代中Eden区和Suvivor区域的容量比,默认数值为８，Eden:Survivor=8:1</td>
<td>Serial&amp; ParNew&amp;Parallel Scavenge</td>
</tr>
<tr>
<td>-XX:PretenureSizeThreshold</td>
<td>设置直接晋升到老年代的老年代的对象大小，设置这个参数后，大于这个参数的对象将在老年代分配，单位字节</td>
<td>所有经典收集器</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold</td>
<td>设置晋升到老年代的年龄，每躲过一次Minor GC对象的年龄＋１，默认此项不设置</td>
<td>所有经典收集器</td>
</tr>
<tr>
<td>-XX:+UseAdaptiveSizePolicy</td>
<td>动态调整java堆区域的大小以及进入老年代的年龄还有停顿时间和吞吐量，特别适合新手</td>
<td>Parallel Scavenge</td>
</tr>
<tr>
<td>-XX:GCTimeRatio</td>
<td>GC时间站总时间的比率，默认为99, 即允许1％的ＧＣ时间</td>
<td>Parallel Scavenge</td>
</tr>
<tr>
<td>-XX:MaxGCPauseMillis</td>
<td>设置ＧＣ最大的停顿时间</td>
<td>Parallel Scavenge</td>
</tr>
<tr>
<td>-XX:CMSInitiatingOccupancyFraction</td>
<td>设置CMS老年代的空间被使用多少时进行收集，默认值为68％</td>
<td>CMS</td>
</tr>
<tr>
<td>-XX:+UseCMSCompactAtFullCollection</td>
<td>完成垃圾回收后是否进行一次内存碎片整理</td>
<td>CMS</td>
</tr>
<tr>
<td>-XX:CMSFullGCsBeforeCompact</td>
<td>设置进行多少次垃圾回收之后再启动一次内存碎片整理</td>
<td>CMS</td>
</tr>
</tbody></table>
<p>列完参数我们发现，大部分的调节参数集中在Paraellel Scavenge 收集器和ＣＭＳ收集器当中，那我们再聊聊这俩个收集器<br></p>
<h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a><font color=#3.5169E1>Parallel Scavenge 收集器</font></h4><p>Parallel Scavenge 收集器，恩命名方式突然多了一个Scavenge一定有特殊之处，的确如此，Scavenge 收集器提供了两个重要的可控指标给我们，那就是<font color=#00ff00>吞吐量和停顿时间</font>，这是之前提到过的，拿第一个来说,</p>
<ul>
<li><font color=#00ff00>程序的吞吐量=运行用户代码的时间/(运行用户代码的时间+运行垃圾收集的时间)</font></li>
</ul>
<p>而在Scavenge收集器当中的参数就是<font color=#00ff00>GCTimeRatio</font> 表示GC回收的时间比率，正好和吞吐量取倒，比如说这个参数取19,那么他所占的用户时间比率为１/(1+19),即百分之五<br/><br>而Scavenge的另一个参数便是，<font color=#00ff00>ＭaxGCPauseMills</font> ＧＣ最大的停顿时间，这个没有什么可讲的，单位为毫秒<br/><br>不过这个参数在使用的时候需要注意，停顿时间和吞吐量的参数设置是矛盾的，如果停顿时间设置比较小，虚拟机为了保持回收效率，会增加回收次数，这样回收次数＊回收时间＝总的回收时间，如果停顿时间设太短，回收次数将增加很多，其最后的结果势必会使吞吐量也降下来．<br/><br><font color=#00ff00>UseAdaptiveSizePolicy</font>，这个参数说明的已经很详细，不再多赘述，如果你对收集器不了解，请务必把这项参数打开．</p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a><font color=#3.5169E1>CMS收集器</font></h4><p>CMS收集器，是一个跨时代意义的收集器，因为自它开始，之后的收集器都实现了并发标记并发收集的功能，它自己也如此，但需要注意的是即使并发收集也有一些停顿避免不了(初始标记GC Root对象时，也会产生停顿)．好了，让我们来看看它的参数<br><font color=#00ff00>CMSInitiatingOccupancyFraction</font>　既然是并发执行，那么我们不能等老年代区满了再去执行，因为在回收过程中用户线程还在执行，我们需要预留一部分空间给用户线程，所以才有这个参数，jdk5 默认值为６８，jdk6默认值为９２，jdk6设置有些风险，因为在程序运行过程中，如果回收之后的老年代空间不足以用户使用，会出现＂并发失败＂，这时会临时启用Serial Old收集器，势必会拖慢用户线程的运行.</p>
<p><font color=#00ff00>+UseCMSCompactAtFullCollection　和　CMSFullGCsBeforeCompact</font> 这两个参数同时讲，我们知道ＣＭＳ收集器是基于标记－清除算法的，这可能会导致老年代没有连续的空间来存储大对象而导致full GC.所以就需要通过这两个参数来设置和整理（两个参数在jdk９开始废弃）</p>
<h3 id="最后简单总结一下问题"><a href="#最后简单总结一下问题" class="headerlink" title="最后简单总结一下问题"></a><font color=#3.5169E1>最后简单总结一下问题</font></h3><ul>
<li>安全点有了，为什么需要安全区域？</li>
<li>新生代老年代如何一同收集？</li>
<li>经典收集器的参数？</li>
<li>简单说一下Parallel Scavenge 收集器和ＣＭＳ收集器的特征．</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lemcoden.github.io/2020/06/18/jvm%E7%9A%84%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%88%BD%E5%8F%A3%E8%AE%B2%E8%A7%A3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BF%97%E7%A7%B0%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89%E3%80%87%E5%8F%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://picture.lemcoden.xyz/avater.jpeg">
      <meta itemprop="name" content="Lemcoden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemcoden">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/18/jvm%E7%9A%84%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%88%BD%E5%8F%A3%E8%AE%B2%E8%A7%A3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BF%97%E7%A7%B0%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89%E3%80%87%E5%8F%81/" class="post-title-link" itemprop="url">jvm的轻量级爽口讲解--内存管理子系统（俗称垃圾回收）〇叁</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-06-18 20:22:33" itemprop="dateCreated datePublished" datetime="2020-06-18T20:22:33+08:00">2020-06-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-06-25 19:05:52" itemprop="dateModified" datetime="2020-06-25T19:05:52+08:00">2020-06-25</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">jvm虚拟机</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h4><p><a target="_blank" rel="noopener" href="https://lemcoden.xyz/2020/05/27/jvm的轻量级爽口讲解-内存管理子系统（俗称垃圾回收）〇贰/">jvm的轻量级爽口讲解–内存管理子系统（俗称垃圾回收）〇贰</a><br/><br>其中对象的引用链路描述有误，现已经更改（应该是查找根节点引用的对象，而不是查找引用根节点的对象）</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hey！guys，I&#x27;m back,关于之前两篇的blog，博主尽可能进行debug，毕竟一篇好的blog是需要经过不断修改打磨的，</span><br><span class="line">就像我们敲过的代码，如果不去不断的重构，之后必将&quot;积重难返&quot;，然后还有一个，关于图片显示的问题，这个博主也</span><br><span class="line">正在全力解决当中，准备把图床转到国内(此行为需要备案)，域名正在备案中.......请大家耐心等待。好了我们继续上一</span><br><span class="line">篇的问题，上一篇我们留下一个关键的问题，如何进行垃圾内存的并发标记，这次，我们就从这个问题开始。</span><br></pre></td></tr></table></figure>

<h3 id="再聊并发可达性分析"><a href="#再聊并发可达性分析" class="headerlink" title=" 再聊并发可达性分析"></a><font color=#3.5169E1> 再聊并发可达性分析</font></h3><p>上一篇关于并发可达性问题，我们只是简单的一笔带过，这次我们利用对象图，帮我们把问题描述的更加清晰一些，以便于更加清晰的理解和解决。首先我们先对对象在对象图中的颜色进行区分定义：</p>
<ul>
<li>白色：表示对象还没有被垃圾回收器访问过，也没有被标记过。</li>
<li>黑色：表示对象已经被访问且标记为安全存活对象（即不是垃圾对象），不会再进行扫描。</li>
<li>灰色：表示对象已经被访问，但是此对象所引用的其他对象至少有一个还没有被扫描过。只有灰色对象所引用的白色对象扫描完毕，其才能被标记为黑色对象，所以说在标记过程中， <font color=#00ff00>黑色对象不能直接指向白色对象</font>。<br/></li>
</ul>
<p>好的，我们看一下标记过程的抽象图：<br>初始过程，黑色的方框对象为根节点，开始向下查找。<br><br><img src="http://picture.lemcoden.xyz/jvm_memory_manage/memory_sign1.png" alt="memory_sign1"><br>中间标记过程，就像是波纹<del>（dio：纳尼？）</del>一样，以灰色对象为波峰持续推进</br><br><img src="http://picture.lemcoden.xyz/jvm_memory_manage/memory_sign2.png" alt="memory_sign2"><br>最后直到所有的灰色对象都查找不到引用，将最后这批灰色对象标记为黑色。</br><br><img src="http://picture.lemcoden.xyz/jvm_memory_manage/memory_sign3.png" alt="memory_sign3"><br>好了，<font color=#00ff00 >正常的标记过程</font>就是如此，但如果有用户线程来捣乱，那就不一样了<br/><br>那用户线程如何捣乱呢？把正在查找的灰色对象对白色对象切断？我们先试一下，以下虚线为切断的引用<br/><br><img src="http://picture.lemcoden.xyz/jvm_memory_manage/memory_sign4.png" alt="memory_sign4"><br>好像结果并没有什么阻碍，最终查找的结果是正确的，因为用户已经切断了引用，而我们的标记结果也实时作出了改变。<br/><br>那么添加黑色对象对已经查找的白色对象的引用呢？<br/><br><img src="http://picture.lemcoden.xyz/jvm_memory_manage/memory_sign5.png" alt="memory_sign5"><br>也同样的不会出现什么问题，最后的结果和原来一致，那么，如果两个同时叠加呢？<br/><br><img src="http://picture.lemcoden.xyz/jvm_memory_manage/memory_sign6.png" alt="memory_sign6"><br>唉？问题就出来了，如果我们切断灰色对象对白色对象的引用，然后用一个黑色对象引用此白色对象，会让这个白色对象到扫描的最后都不会标记为黑色，但他有黑色对象的引用，照这样的标记回收会使我们的回收掉本应该存活的对象。<br/><br>现在，我们知道，要是并发收集出现错误，必须满足以下两个条件：</p>
<ul>
<li>切断从灰色对象到黑色对象的引用</li>
<li>添加已经扫描过的黑色对象对白色对象的引用</li>
</ul>
<p>只要我们破坏其中一个条件，并发标记便可以实现。<br/><br>破坏第一个条件，当探测到切断灰色对象对白色对象的引用，把这个引用记录下来，然后再以记录过的灰色对象为根节点，再扫描一遍，这种方法叫做<font color=#00ff00 >原始快照</font><br/><br>破坏第二个条件，当添加黑色对象到白色对象的引用时，我们将这个黑色对象重置为灰色对象，再进行查找。这种方法叫做<font color=#00ff00>增量更新</font><br>CMS收集器是基于增量更新来做并发标记的，G1、shennandoah则是用原始快照来实现的，这些收集器，会在之后进行专门的一一讲解。</p>
<h3 id="再聊谁实现"><a href="#再聊谁实现" class="headerlink" title=" 再聊谁实现"></a><font color=#3.5169E1> 再聊谁实现</font></h3><p>好了讲了这么多的理论，我们该讲讲实现了，其实还有一些理论还没有涉及，笔者会在下面以及后几篇补上，现在感觉理论比较枯燥，我们还是聊聊实际的吧。<br/><br>接下来我们会聊到一些垃圾收集器，以及垃圾收集器所用到的之前的理论部分。<br/><br>首先，我们先为垃圾收集器进行分类，Serial、ParNew，Parallel  Scavenge，Serial Old，Parallel Old,CMS收集器，笔者称他们为经典的收集器，因为这些收集器都是专门管理新生代，或者老年代的。<br/><br>而之后出现的G1,shennandoah，ZGC收集器，都是新生代，老年代并用的。<br/><br>而 jdk11出现的Epsilon收集器比较特殊，它不做任何回收动作<del>(我要你有何用？)</del>，至于其作用笔者会在之后描述。<br/><br>目前我们只聊了聊经典收集器的理论，所以我们从经典的收集器开始聊起，<br/></p>
<ul>
<li><font color=#00ff00>  Serial </font>收集器（直译是电视连续剧？重在连续这个词）最早出现的垃圾回收器，它适用于单核的CPU，因此特别适合运行客户端方面的应用，虽然在之后的回收器层出不穷，但是在客户端应用方面，Serial收集器一直最低内存消耗发挥着作用。</li>
<li><font color=#00ff00>  ParNew   </font>收集器，专管新生代的多线程收集器<font color=#00FFFF>JDK1.3</font></li>
<li><font color=#00ff00> Parallel Scavenge  </font>ParNew 收集器的进阶版一般Par开头的，都是多线程收集器，这款收集器主打可控的吞吐量，吞吐量？好像是一个新概念，没错，之前我们讲过，停顿时间是衡量垃圾回收性能的重要指标之一，另一个指标便是吞吐量，他是指用户运行时间在整个程序总运行时间（用户运行时间和垃圾回收时间）的占比。他有自己的参数<font color=#00FFFF>JDK1.4</font></li>
<li><font color=#00ff00> Serial Old</font> 收集器 Serial收集器的老年代版本</li>
<li><font color=#00ff00> Parallel Old </font>收集器专门管理老年代的收集器，在此收集器出现之前ParNew 收集器一直初一比较尴尬的境地，因为作为多线程的新生代收集器，他却只能与单线程的Serial 配合使用<font color=#00FFFF>JDK6</font></li>
<li><font color=#00ff00> CMS 划时代意义的收集器</font>，我们之前所说的并发回收就是从这个收集器开始的，<font color=#00ff00>之前的所有收集器，都只能通过停顿其他用户线程进行标记和回收</font>，但是他是老年代的收集器，其次，作为老年代的收集器，它却无法配合Parallel Scavenge使用。</li>
</ul>
<p>以上就是对我们所讲的理论支撑的垃圾回收器的简单介绍，那我们怎么使用他们呢？<br>很简单，只要启动java的时候加入配置参数就好</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java  -XX:+回收器参数   运行的Main类</span><br></pre></td></tr></table></figure>
<p>那么下面给出的回收器参数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>UseSerialGC</td>
<td>使用Serial + Serial Old 收集器</td>
</tr>
<tr>
<td>UseParNewGC</td>
<td>使用ParNew + Serial Old 收集器</td>
</tr>
<tr>
<td>UseConcMarkSweepGC</td>
<td>使用ParNew + CMS+Serial Old 的收集器组合进行回收 ,如果CMS收集器并发收集失败，会切换到Serial Old 收集器</td>
</tr>
<tr>
<td>UseParallelGC</td>
<td>使用Parallel Scavenge + Serial Old 收集器</td>
</tr>
<tr>
<td>UseParallelOldGC</td>
<td>使用 Parallel Scavenge + Parallel Old 收集器</td>
</tr>
</tbody></table>
<p>这是我们目前可以通过参数切换到的收集器参数，我们会在下一篇blog，将参数写的更详尽一些，包括一些收集器的配置参数，和JDK9之后的从参数改变。</p>
<h3 id="再聊一下停顿"><a href="#再聊一下停顿" class="headerlink" title="  再聊一下停顿"></a><font color=#3.5169E1>  再聊一下停顿</font></h3><p>我们前面聊了聊并发标记是如何实现的，现在我们聊一下如何让用户线程停顿，为什么要讲这个？因为可能会出现停顿时间异常的现象，如果我们不懂其中的原理将没有办法定位问题所在。<br/></p>
<p>首先我们先退一步，上一篇博客，我们讲到GC ROOT 其中有很多类型的引用都会被作为GC ROOT，那么随着应用的体量的增大，引用数量必定猛增不减，这种时候我们如果在垃圾回收的时候，再去查询GC ROOT的引用，<br/></p>
<p>那必然是不行的，因此，我们需要先整一个数据结构，在类型加载的时候，就把相关的引用写入数据结构中，这样我们不必在海量的引用中查找，只取数据结构里面的数据便可，<font color=#00ff00>JVM最经典的HotSpot虚拟机就是利用OopMap数据结构这样进行工作的</font>。<br/></p>
<p>好了，GC Root的收集问题得到解决了，但是运行过程当中，引用关系肯定会改变，而JVM指令当中，大部分的指令都会造成引用关系的改变，我们不可能在每条指令后面都加一个OopMap结构，那对回收来说，空间成本将会变得额外的高昂。<br/></p>
<p>因此，存储了OopMap数据结构外，在运行时，JVM会选择某些“特殊的位置”来记录引用信息，这些特殊的位置就叫做<font color=#00ff00>安全点</font>,那么安全点应该如何设置呢？<br/></p>
<p>安全点设置既不能太少而使回收程序等待时间过长，又不能太多增大程序运行负荷，因此安全点一般选在可长时间执行的地方，一般在<font color=#00ff00>方法调用、循环跳转、异常跳转</font>等这些可以指令序列复用的地方。<br/></p>
<h3 id="简单总结一下问题"><a href="#简单总结一下问题" class="headerlink" title="简单总结一下问题"></a><font color=#3.5169E1>简单总结一下问题</font></h3><ul>
<li>如何做到并发可达性分析，方法分为哪几种？</li>
<li>前期新生代，老年代分开管理的回收器都有那些？</li>
<li>安全点是什么？一般在哪里设置</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lemcoden.github.io/2020/06/09/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8D%8E%E5%A4%8F%E4%B8%96%E7%95%8C%E5%90%84%E7%BA%A7%E8%81%8C%E7%A7%B0%E6%9D%83%E9%99%90%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://picture.lemcoden.xyz/avater.jpeg">
      <meta itemprop="name" content="Lemcoden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemcoden">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/09/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8D%8E%E5%A4%8F%E4%B8%96%E7%95%8C%E5%90%84%E7%BA%A7%E8%81%8C%E7%A7%B0%E6%9D%83%E9%99%90%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">泰拉瑞亚-华夏世界各级职称权限简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-06-09 23:25:31" itemprop="dateCreated datePublished" datetime="2020-06-09T23:25:31+08:00">2020-06-09</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-06-25 12:03:03" itemprop="dateModified" datetime="2020-06-25T12:03:03+08:00">2020-06-25</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/terraria%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index"><span itemprop="name">terraria协议</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="关于华夏世界各职称权限以及命令使用此处写一个简单的草稿"><a href="#关于华夏世界各职称权限以及命令使用此处写一个简单的草稿" class="headerlink" title="关于华夏世界各职称权限以及命令使用此处写一个简单的草稿"></a>关于华夏世界各职称权限以及命令使用此处写一个简单的草稿</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>主要是大家一直在问这个职业能干什么，服主不能一个权限教一个人，那样会累死的。。。。。所以写了这一篇简短的权限以及命令简介，注意：所有的命令都是通过聊天框输入生效</p>
<h3 id="游客"><a href="#游客" class="headerlink" title="游客"></a>游客</h3><p>游客基本只有登陆和注册的权限，进入地图后会被钉死在出生点，无法移动。<br>只能通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/register 密码</span><br></pre></td></tr></table></figure>
<p>注册，然后 通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/login 密码</span><br></pre></td></tr></table></figure>

<p>进行登陆</p>
<p>登陆后 会升级成为冒险者</p>
<h3 id="冒险者"><a href="#冒险者" class="headerlink" title="冒险者"></a>冒险者</h3><p>当你升级成为冒险者之后，你就默认获得了挖取破坏世界物块的权限，并且还有使用虫洞药水，通过物品召唤boss，召唤入侵等，你在个人模式都能正常使用的功能，冒险者并无特殊的命令可以使用。</p>
<h3 id="建筑师"><a href="#建筑师" class="headerlink" title="建筑师"></a>建筑师</h3><p>如果你开荒很多轮觉得无趣了，你可以向管理员或者超管申请成为建筑师，建筑师拥有生成任一物品和圈地（冻结部分物块）的权限，超管还赋予了建筑师一项紧急权限———-冻结全世界物块的权限，这样可以及时防止入侵者肆意破坏世界的建筑。不过一旦发现建筑师滥用权限开荒，管理员将进行删号处理（绝不顾惜）。</p>
<h4 id="生成物品"><a href="#生成物品" class="headerlink" title="生成物品"></a>生成物品</h4><p>生成物品及其简单，但是对管理来说特别危险，可以生成任意物品一旦流出，很容易破坏平衡。这就是管理为啥要删号的原因</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/item 物品ID 物品数量</span><br></pre></td></tr></table></figure>
<p>物品ID可以查泰拉瑞亚官方wiki，如果你英语比较好或者会使用chrome翻译的话，可以直接查<a target="_blank" rel="noopener" href="https://tshock.readme.io/docs/item-list-14">Tshock官方的物品清单</a>， 这里会列出所有版本出现的物品，没找到记得去旧版本卡看看。</p>
<h4 id="圈地"><a href="#圈地" class="headerlink" title="圈地"></a>圈地</h4><p>圈地，即划定一个矩形的范围，在这个范围里，普通的冒险者是炸和挖不动物块的。然后有一个简单的问题，要确定一个矩形需要几个点？对，两个点，这个是数学问题，服主就不说明了。<br>所以圈地，就是我们用命令确定两个点，然后系统会自动圈地<br>首先确定第一个点，输入命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/region set 1</span><br></pre></td></tr></table></figure>
<p>输入命令后会出现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HIt a block to Set Ponit1</span><br></pre></td></tr></table></figure>
<p>恩，翻译过来的意思就是 击打物块设置点1，注意是击打，对着空气乱挥是没有用的，击打的地方必须有物块，当你击打成功后会出现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set temp point 1</span><br></pre></td></tr></table></figure>
<p>这个表示设置成功了，如果设置错了，就需要从/region set 1再开始<br>同理设置第二个点就用命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/region set 2</span><br></pre></td></tr></table></figure>
<p>下面怎么做不用我说吧，如果设置错了就再从/region set 2开始<br>然后两个点都设置成功后，可以通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/region define 你设置的区域的名字</span><br></pre></td></tr></table></figure>
<p>通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/region list</span><br></pre></td></tr></table></figure>
<p>列出所有圈地列表，如果有你圈的地的名字，就说明你设置成功了。<br>删除圈地可以用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/region delete 圈地名</span><br></pre></td></tr></table></figure>
<p>来删除</p>
<h4 id="世界物块冻结"><a href="#世界物块冻结" class="headerlink" title="世界物块冻结"></a>世界物块冻结</h4><p>如果某人恶意破坏世界物块，而你有没有圈住自己要保护的那一片地<br>可以通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/antibuild</span><br></pre></td></tr></table></figure>
<p>命令冻结世界物块，及时止损</p>
<h3 id="管理员"><a href="#管理员" class="headerlink" title="管理员"></a>管理员</h3><p>管理员可是说是拥有最多权限的人了，除了上面的所有职业的权限外，管理员还有，设置用户组或者叫职称的权限，调整世界时间的权限，通过命令召唤boss的权限等等<br/><br>服主目前只讲用户组的一般管理.<br/><br>后期会进行更新，或者你可以通过<a target="_blank" rel="noopener" href="https://tshock.readme.io/docs/permissions">Tshock官方文档</a>了解权限和命令<br/><br>首先介绍一下目前的用户组对应的职称名字<br/><br>游客  =&gt; guest  冒险者 =&gt; default 建筑师 =&gt; builders 管理 =&gt; admin <br/><br>如果你想更改用户的职称权限可以通过<br/></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/user group 用户名 用户组名字</span><br></pre></td></tr></table></figure>
<p>修改职称<br/><br>如果你想禁止掉某个用户可以通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ban add 用户名</span><br></pre></td></tr></table></figure>
<p>禁止某用户</br><br>解禁用户可以通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ban del 用户名</span><br></pre></td></tr></table></figure>
<p>删除用户命令是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/user del  用户名</span><br></pre></td></tr></table></figure>
<p>修改世界时间的命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/time 时间格式 HH:mm</span><br></pre></td></tr></table></figure>

<p>好的职称协议目前就讲到这里</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lemcoden.github.io/2020/05/27/jvm%E7%9A%84%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%88%BD%E5%8F%A3%E8%AE%B2%E8%A7%A3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BF%97%E7%A7%B0%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89%E3%80%87%E8%B4%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://picture.lemcoden.xyz/avater.jpeg">
      <meta itemprop="name" content="Lemcoden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemcoden">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/05/27/jvm%E7%9A%84%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%88%BD%E5%8F%A3%E8%AE%B2%E8%A7%A3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BF%97%E7%A7%B0%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89%E3%80%87%E8%B4%B0/" class="post-title-link" itemprop="url">jvm的轻量级爽口讲解--内存管理子系统（俗称垃圾回收）〇贰</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-05-27 21:38:52" itemprop="dateCreated datePublished" datetime="2020-05-27T21:38:52+08:00">2020-05-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-06-25 12:03:44" itemprop="dateModified" datetime="2020-06-25T12:03:44+08:00">2020-06-25</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">jvm虚拟机</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h4><p><a target="_blank" rel="noopener" href="https://lemcoden.xyz/2020/05/21/jvm的轻量级爽口讲解--内存管理子系统（俗称垃圾回收）〇壹/">jvm的轻量级爽口讲解–内存管理子系统（俗称垃圾回收）〇壹</a></p>
<p><code>上回，我们就jvm虚拟机内存的问题一路问下来，整出了整个jvm虚拟的知识点大纲。这次我们就问题树的最小子树，继续往下问，继续往下回答。就上次的某些问题问的有些突然，那些新概念像是不要钱的一样直接涌过来，让人有点懵，这次，笔者会尽可能的把它从哪里来，到哪里去，它的整个来龙去脉给它溜全了。</code></p>
<h3 id="jvm内存为什么使用可达性分析算法而不是使用引用计数器算法实现内存块的标记"><a href="#jvm内存为什么使用可达性分析算法而不是使用引用计数器算法实现内存块的标记" class="headerlink" title="jvm内存为什么使用可达性分析算法而不是使用引用计数器算法实现内存块的标记"></a><font color=#3.5169E1>jvm内存为什么使用可达性分析算法而不是使用引用计数器算法实现内存块的标记</font></h3><h3 id="标记之后再回收？"><a href="#标记之后再回收？" class="headerlink" title=" 标记之后再回收？"></a><font color=#3.5169E1> 标记之后再回收？</font></h3><p>关于整理的书籍，笔者有一本书推荐给大家，那就是 近藤麻理惠的《怦然心动的人生整理魔法》，近藤麻理惠是日本比较出名的整理大师，笔者最喜欢书中大师最核心的思想，也和我们这一章节要讲的东西很有关系，那就是要学会丢弃，一旦我们判定手中的东西，以后不再使用就可以丢弃他们。<br/><br>作为面向对象的特性，我们甚至可以直接用现实中的整理，类比内存整理，就像那本书的核心思想一样，我们首先要确定内存是否是需要丢弃的垃圾内存，在垃圾回收器这里这个方法我们把它叫做标记算法，嗯对，先标记内存是否可用，再去回收，没毛病。<br/><br>那么我们目前哪些内存标记算法呢？一共两种一种是引用计数器算法，一种是可达性分析算法。</p>
<h3 id="引用计数器算法-amp-可达性分析算法"><a href="#引用计数器算法-amp-可达性分析算法" class="headerlink" title=" 引用计数器算法&amp;可达性分析算法"></a><font color=#3.5169E1> 引用计数器算法&amp;可达性分析算法</font></h3><h4 id="引用计数器算法"><a href="#引用计数器算法" class="headerlink" title=" 引用计数器算法"></a><font color=#3.5169E1> 引用计数器算法</font></h4><p>他的实现很简单，就是给内存中存在的对象添加一个计数器，但它被引用时，它的计数器数值就加一，当它的引用数值变成0，就会被标记为垃圾对象，对其进行回收。<br/><br>引用计数器算法，在垃圾回收领域应用很广泛，包括 Action Script3的FlashPlayer,Python语言以及游戏脚本领域得到许多应用的Squirrel都是使用引用计数器算法，但是在Java领域中却不是这样，我们主流的Java虚拟机（Hotspot,J9等）都没有选用引用计数器算法来标记内存，<br>主要原因是，这个看似实现简单的原理，却有很多意外情况需要处理，比如说比较突出的循环引用问题，<br/><br>举个例子，我们新建两个实例A和B，<br/><br>A实例里面的一个变量引用B，B实例的一个变量引用A，<br/><br>然后我们把A,B实例置空，<br/><br>如果我们的语言使用的引用计数器算法，那么我们的A,B变量将不会被回收，因为实例本身为空了，但是变量的引用还为1。<br/></p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title=" 可达性分析算法"></a><font color=#3.5169E1> 可达性分析算法</font></h4><p><font color="#FFC0CB">通过一系列称为“GC Roots”的根对象作为起始节点，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路程称为“引用链”。</font><br/><br>感觉整个描述比较抽象，不过没关系，一般抽象的概念，在使用过程当中会变得具体，之后笔者会讲分代收集从某些方面是如何应用可达性分析算法，以及如何进行并发状态下的可达性收集，当讲到这一部分的时候，读者可以再会头看看这里。<br/><font size=2>（为了便于回头查找，笔者先把这行文字标识为粉色）</font><br>因为读者表述能力不足，下面这个关于GC Roots一般都包括哪些只能硬背了。</p>
<ul>
<li>在虚拟机栈中（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用方法堆栈中的参数、局部变量、临时变量等。</li>
<li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li>
<li>在方法区中常量引用的对象，譬如字符串常量池里的引用</li>
<li>在本地方法栈帧中JNI（即通常所说的Native方法）引用的对象</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPonitExeception、OutofMemoryError）等，还有系统类加载器。</li>
<li>所有被同步锁（synchronized 关键字）持有的对象</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等<br>为了更形象的表示GC Root的标记过程笔者给出图片</li>
</ul>
<p><img src="http://picture.lemcoden.xyz/jvm_memory_manage/gc_root.png" alt="gc_root"></p>
<p>图片如上。我们通过GC Root节点往下查找他引用的节点，然后再继续查找引用的节点引用的节点<del>禁止套娃</del>，就这样将所有关于GC Root的引用链路查找完毕，最后将那些没有在引用链路中的节点标识为垃圾节点，进行回收<br/></p>
<h4 id="Stop-the-world？并行-and-并发？"><a href="#Stop-the-world？并行-and-并发？" class="headerlink" title="Stop the world？并行 and 并发？"></a><font color=#3.5169E1>Stop the world？并行 and 并发？</font></h4><p>既然可达性分析算法已经讲了，那我们顺便聊聊，标记算法的重点特性，我们知道在jvm虚拟机运行过程中的线程分为两大类，分别是<font color=#00FF00> 用户线程和垃圾回收线程</font> <br><br>两个线程都会对我们上面的引用链路进行操作，那么问题就出来了，<br/><br>如果垃圾回收线程在引用链路查找过程中，用户突然对查找过的引用进行变更操作，那么势必会使回收的变量产生问题，<br/><br>所以，当垃圾回收线程在进行标记的过程中，会让用户线程进入短时间的停顿。这个现象被形象的称之为<font color=#00FF00>Stop the world</font>。所以说Java程序运行过程中，如果使用内存量大的话，用户会感到有明显的<font color=#00FF00>停<br>顿</font>。<br/><br>对，就是<font color=#00FF00>停顿</font>，这是我们对GC回收优化的一个重要指标，如果你是Web端的服务程序，那么停顿时间这个指标是你的优化首选，毕竟没有哪个用户希望，在他使用服务的过程中经常出现明显的卡顿。<br/><br>好的，讲到停顿，那么我们可不可以不进行停顿呢？答案是当然的,我们可以让用户线程和垃圾回收线程进行<font color=#00FF00>并发执行</font>。<br/><br>什么？并发?对就是读者所理解的让回收线程和用户线程抢占CPU的时间片，但是这样子还会出现上面那种情况，用户修改标记过后的引用链路，导致回收了错误的对象或者叫变量。这个…………由于篇幅有限，这个问题的答案以及原理我们放到下一篇当中。（还有一个优化指标吞吐量和这个有关系）</p>
<h3 id="回收算法-amp-内存分代"><a href="#回收算法-amp-内存分代" class="headerlink" title="回收算法&amp;内存分代"></a><font color=#3.5169E1>回收算法&amp;内存分代</font></h3><p>既然我们聊完标记了，那么标记之后的回收我们也来聊一聊，应该怎么回收这些垃圾，对垃圾进行分类，哪种垃圾的用哪种算法回收效率最高。<br/><br>关于标题的三个回收算法想必大家都已经很熟悉了，这里就简单用图提点一下概念。重点讲为什么？<br/></p>
<h4 id="回收-清除算法"><a href="#回收-清除算法" class="headerlink" title="回收-清除算法"></a><font color=#3.5169E1>回收-清除算法</font></h4><p>回收算法中简单，最基础的算法，其实就是把标记过后的内存直接清除掉，这样的处理的有点是处理方式简单，回收效率高，但是正因为简单，没有考虑之后的内存插入，可能会导致后面，大对象的插入，会让计算机查找很长时间寻找连续的内存，具体怎么回收直接看下面的简图。<br><img src="http://picture.lemcoden.xyz/jvm_memory_manage/gc_process.png" alt="思维导图"></p>
<h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a><font color=#3.5169E1>标记-复制算法</font></h4><p>为了标记清除算法的缺陷，基于标记-清除算法，又出现了标记-复制算法，简单来说，就是预留一半的内存区域，回收之后，将存活的内存对象紧密排列到预留的区域当中，这样当然可以回收过后得到规整的可用内存区域。但是缺点也很明显，我们需要两倍的内存空间来做，能不能减少预留的空间呢？当然可以，要解决这个问题，我们需要先回到GC的分代问题，为什么jvm内存要分年轻代，老年代？相信大家都知道，jvm堆内存主要分为年轻代，老年代，而年轻代，基本都是使用的标记-复制算法，所谓年轻代，就是内存区域中的大部分对象都是“朝生夕死”的。内存赋值之后，很快就会被标记为可回收，那么我们在年轻代进行回收的时候，就会回收到大量的垃圾对象，而余下存活的对象很少，这样我们就可以把标记-复制算法的预留区域设置的少一点，降低一点标记-复制算法所消耗的内存，在最常用的jvm Hotspot虚拟机当中，<font color=#00FF00>年轻代默认的主内存（eden区）和预留内存（suvivor1区和suvivor2区）</font>的内存比例就达到了8：1：1的比例，也就是两个预留区总共占用百分之20的内存<br><img src="http://picture.lemcoden.xyz/jvm_memory_manage/gc_process1.png" alt="思维导图"></p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a><font color=#3.5169E1>标记-整理算法</font></h4><p>除了设置预留区域之外，我们还可以在内存回收之后进行内存的整理，这样我们也可以使用比较规整的内存区域，其抽象的过程就如下图，但是，如果我们内存回收之后，各个存活对象之间的空白区域很多，那么整理对于我们的回收线程是特别消耗时间和性能的事情，所以我们要找那种回收过程中要回收垃圾对象比较少的区域，这样回收之后，空白区域预留的比较少，可以消耗比较较少的计算资源进行整理，看到这里，你应该能反应到了吧，对就是老年代，这种回收方式对于老年代的内存是再合适不过了，因为老年代中的对象存活率比较高，产生的垃圾对象相对较少。<br><img src="http://picture.lemcoden.xyz/jvm_memory_manage/gc_process2.png" alt="思维导图"></p>
<p>好的，此篇博客基本就讲到这里，我把这此所讲述的问题列出来，当然有些问题仅仅是解决了一半而已，比如说，停顿具体是怎样实现的，并发标记是如何做的，还有一个没有列出来的，记忆集是怎么来的等等，这些问题笔者会在下一篇中写出答案，以下是我的问题列表：</p>
<ul>
<li>垃圾 标记算法有哪些，为什么使用可达性分析算法，而不是引用计数器算法？</li>
<li>jvm回收线程在标记过程中是否会造成停顿，为什么？</li>
<li>垃圾回收算法有哪些，分别什么作用，他和内存分代有什么关系？</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lemcoden.github.io/2020/05/21/jvm%E7%9A%84%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%88%BD%E5%8F%A3%E8%AE%B2%E8%A7%A3--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BF%97%E7%A7%B0%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89%E3%80%87%E5%A3%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://picture.lemcoden.xyz/avater.jpeg">
      <meta itemprop="name" content="Lemcoden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemcoden">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/05/21/jvm%E7%9A%84%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%88%BD%E5%8F%A3%E8%AE%B2%E8%A7%A3--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BF%97%E7%A7%B0%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89%E3%80%87%E5%A3%B9/" class="post-title-link" itemprop="url">jvm的轻量级爽口讲解--内存管理子系统（俗称垃圾回收）〇壹</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-05-21 21:57:35" itemprop="dateCreated datePublished" datetime="2020-05-21T21:57:35+08:00">2020-05-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-06-25 12:03:47" itemprop="dateModified" datetime="2020-06-25T12:03:47+08:00">2020-06-25</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">jvm虚拟机</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>昨天半夜啃书时，笔者突发奇想，要开一个新的系列主题，没错，如标题所言，关于jvm虚拟机的爽口简介，众所周知jvm虚拟机的底层知识相当枯燥，就像是发柴的鸡肉，即使嚼烂也难以下咽，究其原因，是看书的时候问题不明确，只能被博客文章，书中大量知识点牵着鼻子走，因此，笔者准备以问题驱动作为主线，我们先明确要问的问题，整理好问题之间的引用链路，然后再集中解答的方式，先给知识裹一层糖色（shai），让问题变得诱人，再去吃的话就没有那么柴了。那么废话不多说，本系列篇章开始（本篇博客所有问题将有蓝色字体标出，并在博客的最后重复给出，想挑战记忆力的小伙伴可以试着去解答）。</code></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/05/21/jvm%E7%9A%84%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%88%BD%E5%8F%A3%E8%AE%B2%E8%A7%A3--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BF%97%E7%A7%B0%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89%E3%80%87%E5%A3%B9/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lemcoden.github.io/2020/05/20/hexo%E4%BC%98%E5%8C%96-github-coding%E5%8F%8C%E6%90%AD%E5%BB%BA%EF%BC%8C%E5%9F%9F%E5%90%8DCNAME%E5%88%AB%E7%A7%B0%E6%8C%87%E5%90%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://picture.lemcoden.xyz/avater.jpeg">
      <meta itemprop="name" content="Lemcoden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemcoden">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/05/20/hexo%E4%BC%98%E5%8C%96-github-coding%E5%8F%8C%E6%90%AD%E5%BB%BA%EF%BC%8C%E5%9F%9F%E5%90%8DCNAME%E5%88%AB%E7%A7%B0%E6%8C%87%E5%90%91/" class="post-title-link" itemprop="url">hexo优化:github+coding双搭建，域名CNAME别称指向</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-05-20 13:17:20" itemprop="dateCreated datePublished" datetime="2020-05-20T13:17:20+08:00">2020-05-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-06 14:16:23" itemprop="dateModified" datetime="2021-06-06T14:16:23+08:00">2021-06-06</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BB%BA%E7%AB%99/" itemprop="url" rel="index"><span itemprop="name">建站</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>前情提要:<br><a target="_blank" rel="noopener" href="https://lemcoden.xyz/2020/01/05/hexo-github-%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/">hexo + github 搭建教程</a><br><a target="_blank" rel="noopener" href="https://lemcoden.xyz/2020/01/06/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1github-hexo-%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%81%E5%BE%99/">记录一次github + hexo 文件的迁徙</a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><pre><code>    填一下之前搭建博客的坑，之前发布了一篇搭建hexo的博客，有读者(无中生读者)反应，博客搭建完之后，网站访问很慢，的确，在这样的快节奏时代，超过5秒的网页大家都不想打开，所以笔者写了这篇关于博客的优化(感觉不能算作优化，只是填坑)。
</code></pre>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/05/20/hexo%E4%BC%98%E5%8C%96-github-coding%E5%8F%8C%E6%90%AD%E5%BB%BA%EF%BC%8C%E5%9F%9F%E5%90%8DCNAME%E5%88%AB%E7%A7%B0%E6%8C%87%E5%90%91/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lemcoden.github.io/2020/01/26/taking-the-work-out-of-networking-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E9%87%8A%E6%94%BE%E5%86%85%E5%90%91%E8%80%85%E6%BD%9C%E5%9C%A8%E7%9A%84%E8%83%BD%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://picture.lemcoden.xyz/avater.jpeg">
      <meta itemprop="name" content="Lemcoden">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lemcoden">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/01/26/taking-the-work-out-of-networking-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E9%87%8A%E6%94%BE%E5%86%85%E5%90%91%E8%80%85%E6%BD%9C%E5%9C%A8%E7%9A%84%E8%83%BD%E9%87%8F/" class="post-title-link" itemprop="url">taking the work out of networking:第一章 释放内向者潜在的能量</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-01-26 18:09:46" itemprop="dateCreated datePublished" datetime="2020-01-26T18:09:46+08:00">2020-01-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-11-28 18:55:46" itemprop="dateModified" datetime="2020-11-28T18:55:46+08:00">2020-11-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B9%A6%E7%B1%8D%E7%BF%BB%E8%AF%91/" itemprop="url" rel="index"><span itemprop="name">书籍翻译</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <table><tr><td bgcolor=#00FFFF>
如果您觉得作者翻译的内容有帮助，让您学到了相关专业知识，请分享给更多人，让更多人学到大数据知识。您的分享，是作者翻译的动力！
</td></tr></table>
![taking_the_work_out_of_networking]{cover_of_book}
<center>
人际交往更多的是长久的培养种植而不是即时的狩猎
</center>
<p align="right">--伊万·米斯纳</p>
人际交是我们大多数人认为比较繁琐的多数事之一----它是一项需要从事的艰巨的任务，当我们需要一些东西:比如一份新工作，更好的事业指导，更优越的教育，或者其有用的信息时。 当我谈起发展这个想法的时候，几乎我提到的每个人都说同样的话：“我恨人际交往，任何可以帮助我逃避它，逃离它的东西都是极好的”，当我问起我在FaceBook或者Twitter的朋友什么东西是他们尤其仇恨的对于人际交往，他们的回复如下：
“每个人都尝试他们自己做不到的事”
“目标驱动的虚假性，对话是为了实现目标，而不是为了建立联系而感到假。”
“我讨厌不得不和那些试图利用这段关系而可能忘记当前唯一共同目标的人进行表面的对话”
作为一生的性格内向者，强迫介绍和谈论太多关于我自己的事，甚至索要名片的想法一直令人厌恶，当我的日程上排满了会议，电话或者其他事务要求我说很多话，或者在拥挤的人群中，我会感到焦虑。
至今，尽管我自己需要自我保护和独处，但是在我六十七岁的最后已经在世界各地建立了上千的联系人。虽然我永远不会再房间里工作，但我不害怕和任何内向者开始一段对话。在我的长久而多样的职业生涯，我的人际关系每天都会使我的生活更加丰富，朋友和熟人（和他们所知道的人，等等等等）经常来找我，提供想法，支持，联系和介绍，并且我也这么做。
无论您属于内向型还是外向型，建立新连接的人际网络的需求已经不再重要，一些证明点如下：
* 我们经常换工作，年轻的婴儿潮一代在他们的职业生涯中拥有十几份不同的工作，而千禧一代预计会拥有更多(美国劳工统计局)
* 跳槽始于年轻，如今的大学毕业生在毕业后的头五年里，在公司工作的人数是早年的两倍（据领英统计）
* 我们经常搬家，美国人一生中搬家的次数超过11次(FiveThirtEight.com)
* 我们中大部分人为我们自己而工作，在21岁以上的美国人中，有将近4100万个体经营者，而且这一趋势还在增长。（MBO Pattern,Nation1099.com）
这些原因------工作的改变，自由职业化，地理迁徙-----它使我们大多数人都义不容辞地把建立人际关系网作为一种常规做法，在我们的职业生涯中，我们仍需要不断变化，并不断增长的各种各样的人来帮助我们。现代社会对“人际关系网”的定义是：努力与许多人见面、交谈，特别是为了获得对你有帮助的信息，听起来还不错，对吧？
***然而，人们讨厌这样做？***
但是对于大多数人来说，社交网络让人联想到这样一幅画面：在你确保收集到的名片数量相等的情况下，把名片按在眼前的每个人身上.建立人际关系网的其他可怕的方面：为了得到一份新工作不得不去见陌生人；需要了解一个新地域新城市的内幕；试图利用招聘系统来匹配你的经验定位令人有趣的角色.这一切看起来都是虚假的，是赤裸裸的交易，另外，尽管我们花了很多时间避免社交，我们仍然认为必须在最需要社交的时候走出去。当事情看起来最糟糕的时候（即将到来的裁员，没有前途的角色，无法忍受的工作环境），我们会感到脆弱-----又是甚至是绝望。在这种情况下，谁会是最好的？
当然，也有人不相信他们需要社交，毕竟，他们说，他们的工作是安全的。（直到它不是）,还有一些人觉得他们对目前的工作已经听天由命了，因为，坦率地说，他们想不出更好的东西了，或者因为各种各样的原因（终身职位，头衔降级，薪酬降低，通勤物流等等），他们觉得自己负担不起换工作。一个朋友向我描述了关于人际交往困惑他一生的难题：“传统上在社交场合中不允许讨论工作，不能妄尊自大，不能自我推销，不能投机取巧，不能利用朋友-----然后，作为专业的成人，必须以某种方式让自己融入市场上，这种冲突好像从来不会让人觉得不尴尬。”
对于内向的人来说，与陌生人交流的厌恶甚至恐惧会成倍增加。正如卡尔•荣格(Carl Jung)所描述的那样，内向的人需要独处的时间来充电，他们通过独处来恢复精力——而外向的人则通过与人交往而获得一种特殊的能量，他们似乎不需要休息。我们大多数人都在这两者之间。根据我自己的经验，以及我从同类的灵魂那里听到的，我们这些倾向于内向的人，比起我们在喋喋不休的人群中，更能自如地表达我们的思想。在谈话或嘈杂的房间里挤来挤去是最糟糕的琐事。在我重新回到这个世界之前，我需要一个计划外的时间来让我的大脑漫游并恢复活力。你也是吗?
2000年，硅谷经历了一次重大的经济衰退。那年，我加入了一家拥有18名员工的初创公司，这是一家早期的电子商务个人礼品商，名为Violet.com。经过了四个多月的动荡，我们彻底歇业了；没有新一轮的融资。我去了一家知名的代理机构，该机构正在旧金山开设办事处，结果时机不好（经济下滑导致引诱不到客户），不久公司就搬到洛杉矶的办公室-------其中不包括我。最后，我几乎没有什么工作可以从事，甚至于合同工作也很少。没有人在招聘。在接下来的15个月左右的时间里，我因工作或金钱不足而苦苦挣扎。我和我的同僚成立了一个非正式的支持小组，供几个朋友使用。我们每周见面，互相欢呼并分享线索。看看他们是否需要写作帮助。其中一个电话时打给我之前和我一起工作两次的朋友，他最近在一家名为Google的创业公司工作。我问她是否需要写作帮助；他告诉我他们只是聘请了一名市场营销作家，但打印让我牢记。
几个月后，她回了我电话。工作似乎堆积如山。我要进来见团队吗？她强调说，她不能直接雇佣我；其他人将不得不喜欢我的工作（和我）。我一定时风雨如磐的港口，因为在他们第一次见面的时，他们就要求我加入，我很热心几周之内，很明显，我影噶

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>
<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lemcoden</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="0" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  <script class="next-config" data-name="mermaid" type="application/json">{&quot;enable&quot;:true,&quot;theme&quot;:&quot;forest&quot;,&quot;js&quot;:{&quot;url&quot;:&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;mermaid@8.9.3&#x2F;dist&#x2F;mermaid.min.js&quot;,&quot;integrity&quot;:&quot;sha256-OyJHvRcZHaRR6Ig73ppxF4QXk8HzvfgTprRWkulCkfY&#x3D;&quot;}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script class="next-config" data-name="nprogress" type="application/json">{&quot;enable&quot;:true,&quot;spinner&quot;:true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{&quot;enable&quot;:true,&quot;tags&quot;:&quot;none&quot;,&quot;js&quot;:{&quot;url&quot;:&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;mathjax@3.1.4&#x2F;es5&#x2F;tex-mml-chtml.js&quot;,&quot;integrity&quot;:&quot;sha256-ncNI9OXOS5Ek4tzVYiOMmN&#x2F;KKCPZ6V0Cpv2P&#x2F;zHntiA&#x3D;&quot;}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
